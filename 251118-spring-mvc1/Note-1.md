아래에서는 SSR(Server-Side Rendering)과 CSR(Client-Side Rendering)을 비교하면서 각각이 무엇이고, 어떤 원리로 동작하며, 언제 어떤 방식을 선택하면 좋은지까지 정리해줄게.

---

# 1. SSR(Server-Side Rendering)

## 개념

초기 HTML을 서버에서 미리 완성해서 브라우저로 보내는 방식이다.
브라우저는 전달받은 HTML을 그대로 렌더링하기 때문에 페이지가 빠르게 보인다.

## 동작 원리

1. 브라우저가 URL 요청을 보냄
2. 서버가 필요한 데이터를 조회
3. 서버가 HTML 템플릿을 렌더링하여 완성된 HTML을 생성
4. 완성된 HTML을 브라우저에 전달
5. 브라우저는 바로 화면을 그림
6. (필요하다면) JS가 추가로 동작해서 인터랙션을 제공

## 장점

* 초기 렌더링이 빠름
* SEO에 유리 (HTML이 이미 채워져 있음)
* JS가 없거나 느린 환경에서도 어느 정도 보여줌
* 초기 화면이 빨리 보이기 때문에 체감 퍼포먼스가 좋음

## 단점

* 서버 부하 증가
* 페이지 전환 시 새로고침이 발생하는 전통 SSR 구조에서는 “앱 같은 부드러운 전환”이 어렵다
* 클라이언트 측에서 상태(state)를 유지하기 어렵다

대표 예: Spring MVC + Thymeleaf, JSP, Rails, Laravel, Next.js(SSR 모드)

---

# 2. CSR(Client-Side Rendering)

## 개념

서버는 빈 HTML + JS 번들만 보내고,
브라우저에서 JS가 실행되며 데이터를 API로 받아 화면을 구성하는 방식이다.

초기 HTML에는 내용이 없음. 브라우저가 JS를 다운로드해 실행한 뒤 화면이 만들어진다.

## 동작 원리

1. 브라우저가 HTML을 받지만 내용이 거의 없음 (div#root 같은 빈 영역)
2. JS 번들을 다운로드
3. JS 코드가 실행되며 API로 데이터 요청
4. 데이터를 받아 DOM을 구성
5. 화면이 렌더링됨

## 장점

* 브라우저 안에서 동작하는 SPA 구조로 만들어 매우 부드러운 페이지 전환
* 상태 관리가 용이 (React state, Redux…)
* 서버 부하가 적어짐
* 프론트와 백엔드 완전 분리 구조 가능

## 단점

* 초기 로딩이 느림
  (JS 파일 다운로드 + 실행 + 데이터 요청까지 해야 화면이 보임)
* SEO가 어려움
  (검색엔진이 JS 실행 전 HTML은 비어 있음)
* JS 성능이 떨어지는 디바이스에서는 체감 성능이 나쁠 수 있음

대표 예: React SPA, Vue SPA, Angular SPA

---

# 3. 쉽게 비교

| 구분          | SSR               | CSR                 |
| ----------- | ----------------- | ------------------- |
| 첫 페이지 표시 시간 | 빠름                | 느림                  |
| 서버 역할       | HTML을 렌더링         | API만 제공             |
| SEO         | 매우 유리             | 기본적으로 불리            |
| 페이지 전환      | 새로고침 발생 가능        | 부드러운 SPA 느낌         |
| 초기 JS 의존    | 거의 없음             | 강함                  |
| 서버 부하       | 높음                | 낮음                  |
| 앱 성격        | 문서형 사이트(블로그, 쇼핑몰) | 앱형 서비스(대시보드, 관리페이지) |

---

# 4. SSR과 CSR을 실제 서비스 기준으로 선택하는 기준

## SSR이 더 낫다

* 검색엔진이 중요한 서비스 (블로그, 뉴스, 쇼핑몰 상품 목록)
* 첫 화면이 빨라야 하는 서비스
* 콘텐츠 기반 서비스
* JS 지원이 제한적일 수 있는 환경

## CSR이 더 낫다

* 로그인 이후 사용하는 웹앱
  (관리자 페이지, 대시보드, 실시간 인터랙션 많은 서비스 등)
* 페이지 전환이 잦고 빠른 응답성이 중요한 경우
* 백엔드/프론트가 완전히 분리된 구조를 원할 때

---

# 5. 최근 트렌드: SSR + CSR 혼합(Hydration 등)

요즘은 Next.js나 Nuxt.js 같은 프레임워크들이 초기 HTML은 SSR로 렌더링,
그 후 CSR로 앱을 이어서 실행하는 구조를 많이 사용한다.

이 방식은:

* 초기 로딩 속도(SSR)
* 이후 부드러운 인터랙션(CSR)

둘 다 챙길 수 있어 현대적 웹앱의 표준 방식처럼 쓰인다.

---

필요하다면 다음도 설명해줄 수 있어

* Hydration / Partial Hydration
* Next.js에서 SSR vs SSG vs CSR 비교
* Spring MVC 기반 서버를 React와 함께 쓰는 아키텍처 구조
* SEO 문제 해결 방법
  원하면 말해줘.

좋아, 이번엔 진짜 코드·네트워크 흐름 수준으로 SSR/CSR 동작 과정을 쭉 따라가 볼게.
(브라우저 → 서버 → 브라우저로 다시 돌아오는 전체 흐름 기준으로 설명할게.)

---

## 0. 공통: 브라우저가 URL을 치면 기본적으로 일어나는 일

SSR이든 CSR이든, 맨 처음에는 둘 다 똑같이 시작한다.

1. 사용자가 주소 입력: `https://example.com/products`
2. 브라우저가 하는 일

   * DNS 조회 → IP 주소 찾기
   * 서버 IP로 TCP 연결(보통 443 포트, HTTPS)
   * HTTP 요청 생성:
     `GET /products HTTP/1.1`
     `Host: example.com`
     기타 헤더...

이제부터 서버에서 HTML을 만들어 보내느냐(SSR),
아니면 대부분의 화면을 JS가 나중에 만들게 하느냐(CSR) 차이가 난다.

---

## 1. SSR 동작 원리 – “서버에서 HTML을 다 만들어서 보낸다”

### 1-1. 서버 입장에서의 흐름 (Spring MVC 예시 느낌)

`GET /members` 요청이 들어왔다고 생각해보자.

1. 서버가 HTTP 요청 수신

   * WAS(Tomcat 등)가 요청을 받고, 서블릿/스프링으로 넘김

2. 라우팅

   * 스프링 MVC가 URL과 컨트롤러 메서드를 매핑

     ```java
     @GetMapping("/members")
     public String list(Model model) {
         List<Member> members = memberService.findAll();
         model.addAttribute("members", members);
         return "members/list"; // 뷰 이름
     }
     ```

3. 비즈니스 로직 + 데이터 조회

   * `memberService.findAll()`이 DB에서 회원 목록 조회
   * 조회 결과를 `model`에 넣음

4. 템플릿 렌더링

   * ViewResolver가 `"members/list"`를 실제 템플릿 파일로 매핑
     예: `/templates/members/list.html` (Thymeleaf)
   * 템플릿 엔진이 `${members}` 같은 표현을 실제 값으로 치환해서
     완전히 HTML 문자열을 만들어냄
   * 예시 (서버 내부에서 최종적으로 생성되는 HTML 일부):

     ```html
     <table>
       <tr><td>user1</td></tr>
       <tr><td>user2</td></tr>
     </table>
     ```

5. HTTP 응답 전송

   * 응답 헤더:
     `HTTP/1.1 200 OK`
     `Content-Type: text/html;charset=UTF-8`
   * 응답 바디: 방금 만든 완성된 HTML 전체

### 1-2. 브라우저 입장에서의 흐름

1. HTML 수신

   * 브라우저의 HTML 파서가 위에서부터 태그를 해석한다.

2. DOM 트리 구성

   * `<html>`, `<body>`, `<table>` 등을 파싱해 DOM 트리 생성
   * 동시에 `<link rel="stylesheet" ...>`, `<script src="...">`를 만나면 CSS, JS를 또 HTTP 요청으로 가져온다.

3. CSS 적용, 레이아웃 계산, 페인트

   * CSS 파싱 → 스타일 계산
   * 레이아웃 계산 → 화면에 페인트
   * 사용자는 이미 내용이 채워진 화면을 볼 수 있음

4. JS 실행 (있다면)

   * `<script>`로 받은 JS가 실행돼서

     * 버튼 클릭 이벤트 등록
     * Ajax 호출 준비
     * 간단한 동적 동작들 추가

→ 중요한 점:
화면 내용(데이터 포함된 HTML)을 만드는 주체가 “서버”라는 것.
브라우저는 받은 HTML을 “그대로 보여주기만” 하면 된다.

### 1-3. SSR에서 페이지 이동

1. 사용자가 링크 클릭

   ```html
   <a href="/members/1">상세</a>
   ```
2. 브라우저는 다시 새로운 HTTP GET 요청을 보낸다:
   `GET /members/1`
3. 서버는 위와 동일하게

   * 라우팅 → 서비스/리포지토리 → 템플릿 렌더링 → HTML 응답
4. 브라우저는 기존 화면을 버리고 새 HTML로 전체 화면을 다시 그림
   (전통적인 웹 사이트 느낌: 새로고침되면서 페이지 전환)

---

## 2. CSR 동작 원리 – “브라우저에서 JS가 HTML을 만든다”

CSR은 처음에 오는 HTML 자체가 거의 비어 있음에 가깝다.

### 2-1. 첫 요청에서의 흐름

사용자가 `https://spa.example.com/products`에 접속했다고 하자.

1. 브라우저 → 서버:
   `GET /products HTTP/1.1`

2. 서버가 보내는 HTML (CSR 구조)

   ```html
   <!DOCTYPE html>
   <html>
   <head>
     <title>My SPA</title>
   </head>
   <body>
     <div id="root"></div>
     <script src="/static/js/main.js"></script>
   </body>
   </html>
   ```

   * 실제 내용은 `<div id="root"></div>` 뿐
   * 나머지 진짜 UI는 `/static/js/main.js` 안에 들어있다.

3. 브라우저에서 HTML 파싱

   * DOM 생성: `<div id="root">`만 있는 단순 구조
   * `<script src="...">`를 만나면 JS 파일을 다운로드 요청

4. JS 번들 다운로드 & 실행

   * `main.js` 파일에는 React/Vue/Angular 코드 + 앱 코드가 번들된 상태
   * 이 JS가 실행되면서 보통 이런 코드를 호출한다:

     ```js
     // React 예시
     ReactDOM.createRoot(document.getElementById("root"))
       .render(<App />);
     ```

5. JS가 “클라이언트에서 렌더링” 수행

   * `App` 컴포넌트 내부에서

     * 라우터 설정
     * 초기 페이지 결정 (예: `/products`면 상품 목록 페이지 컴포넌트)
     * 상품 목록을 가져오기 위해 API 호출 실행

       ```js
       fetch("/api/products")
         .then(res => res.json())
         .then(data => setProducts(data));
       ```

6. API 응답

   * 서버는 이번엔 HTML이 아니라 JSON만 돌려준다:

     ```json
     [
       { "id": 1, "name": "상품1" },
       { "id": 2, "name": "상품2" }
     ]
     ```

7. JS가 JSON으로 DOM 생성

   * `setProducts` 호출 → React state 업데이트
   * React가 Virtual DOM을 만들고, 실제 DOM과 비교(diff)해서

     * `<li>상품1</li>`, `<li>상품2</li>` 같은 요소를 실제 DOM에 삽입
   * 브라우저 화면에 비로소 상품 목록이 보인다.

→ 여기서 중요한 점:
서버는 HTML을 만들지 않는다.
서버는 대부분 `/index.html`(빈 틀) + `/static/js/main.js`(앱 코드) + `/api/...`(JSON) 정도만 제공한다.
실제 HTML 요소들은 브라우저에서 JS가 만들어서 DOM에 붙인다.

---

### 2-2. CSR에서 페이지 이동

React Router 같은 걸 쓴다고 가정하자.

1. 화면에 이런 코드가 있을 수 있다.

   ```jsx
   <Link to="/products/1">상세</Link>
   ```

2. 사용자가 이 링크를 클릭하면,

   * 진짜 `<a href="/products/1">` 클릭일 수도 있지만,
   * React Router가 클릭 이벤트를 가로챈다.

3. 가로챈 뒤 하는 일

   * 브라우저에 실제로 새로운 HTTP 요청을 보내지 않고
     `history.pushState()`를 호출해 URL만 `/products/1`로 바꾼다.
   * 내부적으로 “현재 라우트가 `/products/1`이 되었네?”라고 인식하고
   * `ProductDetailPage` 컴포넌트를 렌더링한다.

4. 상세 데이터 필요 시

   ```js
   useEffect(() => {
     fetch("/api/products/1")
       .then(res => res.json())
       .then(setProduct);
   }, []);
   ```

   * 다시 API 호출 → JSON 응답 → state 업데이트 → DOM 업데이트

5. 전체 흐름의 특징

   * 브라우저는 `/products/1`로 새로운 HTML을 받지 않는다.
   * URL은 바뀌지만 네트워크상으로는 JSON API만 왔다 갔다 할 뿐이다.
   * 화면 전환이 아주 빠르고 부드럽다.
     (HTML 전체를 다시 다운로드하지 않으니까)

---

## 3. 네트워크 관점에서 SSR vs CSR 차이

### SSR

* `/members` 요청 → 응답: HTML
* `/members/1` 요청 → 응답: HTML
* `/members/2` 요청 → 응답: HTML
* 페이지 이동마다 HTML 전체를 새로 받아온다.

### CSR

* 맨 처음

  * `/` 또는 `/products` 요청 → 응답:

    * `index.html` (틀만 있음)
    * `main.js` (JS 번들)
  * 이 후 단계에서

    * `/api/products` → 응답: JSON
    * `/api/products/1` → 응답: JSON
* 페이지 이동은 대부분 JS 라우터 + API JSON 통신으로 처리된다.

---

## 4. 렌더링 시점 관점에서 SSR vs CSR

### SSR

* “렌더링”이 서버에서 일어난다.
* 브라우저에 도착할 때 이미 HTML에 내용이 채워져 있음.
* 브라우저는 파싱 + 페인트만 하면 된다.
* 초기 화면 표시가 빠르지만, 페이지 이동 때마다 전체 다시.

### CSR

* 초기에는 렌더링할 내용이 없다시피 함.
* 브라우저는

  1. HTML 파싱 (대부분 빈 껍데기)
  2. JS 다운로드
  3. JS 실행
  4. API 호출
  5. 데이터를 받은 뒤에야 DOM 생성
* 그래서 첫 화면이 뜨기까지 단계가 많고 느릴 수 있다.
* 하지만 한 번 앱이 올라가면 이후 전환은 빠르다.

---

## 5. 혼합 방식(SSR + CSR, Hydration) 간단 맛보기

요즘 React(Next.js) 같은 데서 하는 건:

1. 서버에서 첫 HTML을 React로 미리 렌더링 (SSR)
2. 그 HTML을 브라우저로 보내서 빠르게 화면을 보여줌
3. 그다음 브라우저에서 JS 번들이 로드된 후,

   * 서버에서 렌더링한 HTML과
   * 클라이언트의 React 컴포넌트를 “이어붙이는(hydration)” 작업 수행
4. 이후부터는 CSR처럼 동작 (SPA처럼 빠른 전환)

이건 나중에 더 깊게 이야기해도 되고,
지금은 “SSR의 초기 속도 + CSR의 부드러운 앱 경험을 합친 것” 정도로 이해하면 충분해.

---

만약 네가 지금 공부 중인 스택(예: Spring MVC + Thymeleaf, Spring + React 분리 구조, Next.js, Vue 등)을 알려주면
그 스택 기준으로 요청 하나가 들어왔을 때 내부에서 어떤 메서드들이 호출되고, 어떤 객체가 어떤 역할을 하는지까지 구체적으로 흐름을 그려줄게.

“브라우저 종류가 다양하니까 CSR이 더 나은 거 아닌가?”라고 생각할 만한 포인트는 충분히 있어.
하지만 실제로는 브라우저 다양성 때문에 CSR이 더 낫다고 결론 내리기는 어렵고, 오히려 반대되는 경우도 많다.
아래에서 이유를 정리해볼게.

---

# 1. 브라우저가 다양할수록 CSR이 유리한 부분

## 1) 모든 로직이 JS로 통일되기 때문에 일관성 확보가 쉽다

CSR은 렌더링 로직이 클라이언트(JS)에서 동작한다.
서버가 어떤 환경이든, 클라이언트가 어떤 OS든, 어떤 서버 기술을 쓰든,
JS 하나로 동일한 렌더링 로직을 쓰므로 개발자 입장에서 제어가 쉽다.

즉:

* 사파리, 크롬, 파이어폭스, 엣지에서
  모두 React/Vue 같은 환경이 동일하게 동작함
* 렌더링 차이가 있더라도 대부분 JS 수준에서 조정 가능

이 점은 분명 CSR의 장점이다.

---

# 2. 하지만 브라우저가 다양할수록 CSR이 단점도 커진다

CSR은 브라우저에게 무거운 일을 많이 시킨다.

## 1) JS 해석 성능 차이가 크다

브라우저마다 JS 엔진 성능이 다르다.

* 크롬: V8
* 파이어폭스: SpiderMonkey
* 사파리: JavaScriptCore
* 삼성 브라우저, UC 브라우저, 저사양 기기들도 다양

특히 모바일 저가형 기기에서는:

* JS 번들 다운로드가 느리고
* 파싱이 느리고
* 메모리가 부족해서 앱이 버벅되거나 다운되기도 한다

CSR은 브라우저 성능이 약할수록 직격탄을 맞는다.

SSR은?

* 서버 CPU가 대신 렌더링하므로 저사양 기기에서도 빠르게 화면을 보여줄 수 있다.

---

## 2) 초기 로딩이 브라우저마다 큰 편차를 보인다

CSR 초기 로딩 과정:

1. HTML 다운로드
2. JS 번들 다운로드
3. JS 파싱
4. JS 실행
5. API 요청
6. 화면 렌더링

이 과정은 브라우저 성능과 네트워크 환경의 영향을 많이 받는다.
예) 구형 iPhone Safari는 JS 파싱이 매우 느리다.

SSR은?

* HTML만 받아서 DOM 구성 → 바로 보여줌
* 화면 표시 시점이 브라우저 성능에 거의 영향을 받지 않는다

---

## 3) SEO 문제는 CSR에서 브라우저 다양성과 무관하게 항상 불리

직접적인 브라우저 문제는 아니지만,
다양한 크롤러(검색엔진)도 일종의 “다른 브라우저”라고 본다면
CSR이 불리한 점이 이어진다.

---

# 3. 브라우저 다양성을 기준으로 비교해보면?

| 기준              | SSR              | CSR                  |
| --------------- | ---------------- | -------------------- |
| 브라우저 JS 성능 의존도  | 거의 없음            | 매우 높음                |
| 저사양/구형 브라우저 호환성 | 매우 안정적           | 편차 큼                 |
| 초기 속도           | 브라우저 종류와 무관하게 빠름 | 기기·브라우저 성능 따라 크게 달라짐 |
| 렌더링 일관성         | 템플릿 엔진이 처리 → 안정적 | JS 엔진마다 미묘한 차이 존재    |
| 앱처럼 동작하는 UI     | 부족함              | 매우 좋음                |

CSR은 브라우저 성능이 좋아야 진가를 발휘한다.
브라우저가 다양하고 저성능 기기가 많다면 SSR이 안전한 선택이다.

---

# 4. 실제 대형 서비스들은 어떻게 하고 있을까?

* 구글, 넷플릭스, 트위터, 페이스북, 네이버 등
  대부분의 기업은 SSR + CSR 혼합 방식을 쓴다.
  이유는 명확하다.

1. SSR로 초기 HTML 제공 → 어떤 브라우저에서도 빠른 초기 화면
2. 그 후 CSR로 앱처럼 동작 → 부드러운 UX

이 조합이 실무 기준에서 가장 안정적이고 성능이 높다.

---

# 5. 결론

“브라우저가 다양하니까 CSR이 더 낫다”는 결론은 성립하기 어렵고 오히려 반대다.

* 다양한 브라우저
* 다양한 성능
* 다양한 네트워크 환경

이런 조건이 많을수록 CSR은 초기 성능 문제가 커진다.
SSR은 거의 모든 브라우저에서 동일하게 빠르게 동작하므로 더 안정적이다.

---

원하면 아래도 더 자세히 설명해줄게.

* SSR/CSR을 실제 코드로 비교 (React vs Spring MVC)
* Hydration이 왜 브라우저 다양성 문제를 해결하는지
* SPA의 JS 번들 최적화(코드 스플리팅, lazy loading)
* 실제 서비스에서 SSR/CSR 선택 기준

어떻게 이어서 볼까?

결론부터 말하면,
맞다. SSR이든 CSR이든 *최종적으로 브라우저가 렌더링하는 기준은 HTML이다.*
다만, 그 HTML을 누가 언제 만드느냐가 다를 뿐이다.

아래에서 정확하게 짚어볼게.

---

# 1. 브라우저가 렌더링할 수 있는 것은 결국 HTML뿐이다

브라우저의 렌더링 파이프라인은 기본적으로 이렇게 생겼다.

1. HTML 파싱 → DOM 트리 생성
2. CSS 파싱 → CSSOM 생성
3. DOM + CSSOM → Render Tree
4. 레이아웃 계산
5. 페인트
6. 합성(Compositing)

여기서 핵심은:

* 브라우저는 HTML이 있어야 DOM을 만들 수 있다
* DOM이 없으면 화면에 아무것도 그릴 수 없다
* JS, React, Vue, API JSON … 이런 것들은 모두 중간 과정이고
  결국 브라우저가 화면에 그릴 때는 HTML 기반 DOM이 필요하다

즉:

> *최종 산출물은 언제나 HTML 기반의 DOM이고, 브라우저는 그것을 렌더링한다.*

---

# 2. SSR vs CSR의 차이는 “HTML을 누가 만들었는가”의 차이

## SSR의 HTML 생성 위치

* 서버가 HTML을 완성해서 보냄
* 브라우저는 HTML을 “받기만” 하면 됨

```
[서버: HTML 생성] -> [브라우저: DOM 생성 후 렌더링]
```

## CSR의 HTML 생성 위치

* 서버는 거의 빈 HTML만 보냄
* 브라우저가 JS를 실행해서 HTML(DOM)을 스스로 만든다

```
[서버: 빈 HTML + JS 전송] -> [브라우저: JS 실행 → HTML(DOM) 생성 → 렌더링]
```

여기서도 최종 렌더링 자체는 HTML → DOM → 렌더링 과정이 동일함.

---

# 3. CSR에서 HTML이 눈에 안 보여도 결국 HTML을 생성한다

CSR을 React 기준으로 보면
JS에서 JSX를 쓰잖아?

```jsx
<div>Hello</div>
```

이게 실제로는 이런 구조다:

```js
React.createElement("div", null, "Hello")
```

그리고 이 값은 실제 DOM API를 통해 HTML 요소가 된다.

```js
document.createElement("div");
```

CSR에서는

* HTML 파일이 빈 상태일 뿐
* JS가 실행되어 DOM API로 HTML 요소를 만들어 붙이는 것이다

즉 CSR도 결국:

> JS가 HTML(DOM)을 동적으로 생성하고,
> 브라우저는 그 DOM을 렌더링한다.

---

# 4. 서버 사이드 렌더링 vs 클라이언트 사이드 렌더링의 본질 요약

### SSR의 본질

* 서버가 HTML을 미리 만들어서 내려줌
* 브라우저는 거의 조립만 하면 됨
* 첫 화면이 빠르게 뜸

### CSR의 본질

* 브라우저가 JS를 받아서 HTML을 직접 만들어야 함
* JS 의존도가 매우 높음
* 초기 렌더링이 느릴 수 있음
* SPA처럼 동작함

### 공통점

* 브라우저 렌더링의 최종 단계는 항상 HTML 기반 DOM

---

# 5. 그럼 JSON은 뭐지? 템플릿은? JSX는?

전부 HTML을 생성하기 위한 재료일 뿐이야.

* SSR: 템플릿 엔진(Thymeleaf, Mustache)이 HTML 문자열을 서버에서 생성
* CSR: JS(React, Vue)가 HTML 요소를 브라우저에서 생성
* JSON: HTML을 만들기 위해 브라우저 JS가 참고하는 데이터
* JSX: HTML을 쉽게 쓰기 위한 문법적 설탕
* API 응답: HTML에 들어갈 데이터를 전달하는 역할

모두 다 결국 HTML(DOM)을 만들기 위한 중간 표현이다.

---

# 6. 결론

### 질문: “결국 렌더링의 기준은 HTML인가?”

정확하게 맞다.
CSR이든 SSR이든 브라우저가 그리는 최종 결과는
항상 HTML 기반 DOM이다.

* SSR: 서버가 HTML 생성
* CSR: 브라우저(JS)가 HTML 생성
* 렌더링: HTML → DOM → CSS 적용 → 화면 표시

> 방식만 다를 뿐, 렌더링의 최종 기준은 HTML이다.

---

원하면

* DOM이 실제 내부적으로 어떻게 생겼는지
* React/Vue가 DOM을 어떻게 조작하는지
* SSR/CSR에서 hydration이 왜 필요한지
* 브라우저 렌더링 과정(파싱 단위, 토크나이징, 렌더 트리 등)
  같은 더 원리적인 부분도 이어서 설명해줄게.

프록시 서버나 브라우저가 캐싱하는 “내용”은 정확히 어떤 리소스를 저장해두었다가 다음 요청 때 다시 사용하느냐의 문제다.
이걸 구조적으로 나누어 정리해줄게.

---

# 1. 브라우저 캐시가 저장하는 내용

브라우저는 HTTP 응답을 그대로 저장한다.
대표적으로 다음을 캐싱한다.

## 1) 정적 파일(Static Assets)

가장 흔하게 캐싱되는 것들이다.

* HTML
* CSS
* JavaScript
* 이미지(png, jpg, svg)
* 폰트 파일(woff, woff2, ttf)
* 비디오/오디오 파일

특히 JS/CSS/이미지/폰트 같은 정적 리소스는
한 번 받아놓으면 다음 페이지에서 다시 받을 필요가 없기 때문에
캐시하면 성능이 크게 좋아진다.

### 캐싱의 저장 방식

브라우저는 보통 이렇게 저장한다.

* 응답 바디 전체
* 응답 헤더 중 일부 (Cache-Control, ETag 등)

---

# 2. 브라우저 캐시는 “HTML 자체”도 캐싱할 수 있지만 거의 잘 안 한다

이유는:

* HTML은 동적일 가능성이 높다
* 매번 최신 상태여야 할 수 있다
* 서버에서 “캐시하면 안 된다”라고 헤더로 제어하는 경우가 많다

그래서 보통:

* `/index.html` → 캐시하지 않음
* `/static/js/main.js?hash` → 오래 캐시
* `/static/css/styles.css?hash` → 오래 캐시
  이런 구조가 많다.

---

# 3. 프록시 서버(중간 캐시), CDN이 캐싱하는 내용

프록시 서버나 CDN은 브라우저와 원 서버 사이에서 캐시를 저장하는 중간 서버다.
여기도 기본적으로 HTTP 응답 전체를 캐싱한다.

## 1) 캐싱 대상 파일

브라우저 캐시와 비슷하지만 훨씬 광범위하다.

* HTML
* 정적 리소스(JS/CSS/이미지)
* API 응답(JSON)
* 동적 HTML도 조건부로 캐시 가능
* 인증 필요 없는 공개된 모든 리소스

CDN은 캐싱 정책만 맞으면 무엇이든 캐시한다.

예)

* 상품 목록 API 응답
* 뉴스 기사 HTML
* 블로그 글
* 검색 결과 페이지

이런 것들도 캐시된다.

---

# 4. 프록시/브라우저가 캐싱할 수 있는 근거: HTTP 캐시 헤더

캐싱 여부는 응답 헤더가 결정한다.

## 대표적인 캐시 제어 헤더

* `Cache-Control`
* `Expires`
* `ETag`
* `Last-Modified`

예)

```
Cache-Control: max-age=3600
```

→ 1시간 동안 캐시해서 새 요청 보내지 말라는 의미

```
Cache-Control: no-store
```

→ 절대 캐시하지 말라는 의미

```
ETag: "abc123"
```

→ 브라우저/프록시는 다음 요청 시
`If-None-Match: "abc123"`를 보내 캐시 검증을 함

---

# 5. 캐싱되는 실제 데이터 구조

### 1) 브라우저

브라우저 캐시는 파일 단위로 저장한다.

* URL을 key로 삼고
* 응답 바디(HTML, CSS, JS 등)와 메타데이터를 저장한다

### 2) 프록시 서버/CDN

* URL + 헤더 + 파라미터 조합으로 캐시 키를 만든다
* 예)

  * `/api/products?page=1`
  * `/api/products?page=2`
    이는 서로 다른 캐시 키가 된다

---

# 6. 그럼 "프록시 서버나 브라우저가 캐싱하는 내용"을 한 문장으로 말하면?

> 브라우저나 프록시가 캐싱하는 것은 HTTP 응답의 바디(파일)와 그것을 어떻게 재사용할지 결정하는 메타데이터(헤더)다.

조금 풀어서 하면:

* HTML
* CSS
* JS
* 이미지
* JSON(API 응답)
* 동영상, 폰트
* 기타 HTTP로 내려오는 모든 리소스
  이 전부 캐시될 수 있다.

캐싱 여부는 서버가 보내는 헤더와 클라이언트의 정책에 따라 결정된다.

---

원하면 다음도 설명해줄게.

* Cache-Control의 정확한 작동 방식
* 브라우저 캐시와 Service Worker Cache의 차이
* 캐시 무효화(cache busting) 전략
* CDN 레이어에서만 캐시하고 브라우저는 캐시하지 않는 구조
* SPA에서 JS 번들 캐싱을 어떻게 최적으로 하는지
