- 8 bit = 0~255, -128~127
- 문자 인코딩: 문자 집합을 통해 문자를 숫자로 변환
- 문자 디코딩: 문자 집합을 통해 숫자를 문자로 변환
- 유니코드: UTF-16 (2byte), UTF-8 (1-4byte)
- 자바: UTF-16 (char 메모리 저장 시) -> (영문 등은 byte로 바꿔 저장)
```
논리형	boolean	1byte	true 또는 false 값
문자형	char	2byte	유니코드 문자를 저장
정수형	byte	1byte	-128 ~ 127
short	2byte	-32,768 ~ 32,767
int	4byte	가장 일반적으로 사용되는 정수형
long	8byte	매우 큰 정수값을 저장
실수형	float	4byte	단정밀도 실수
double	8byte	배정밀도 실수, float보다 더 큰 범위와 정밀도
```
- 자바 음수: 2의 보수
```
2의 보수는 양수의 이진수 표현을 뒤집고(1의 보수), 거기에 1을 더한 것
컴퓨터가 덧셈만으로 음수 연산을 처리할 수 있다.
예를 들어, 8비트 기준으로 +5와 -5를 표현하면:
- +5 → 00000101
- -5 → 11111011 (2의 보수)
계산 방법 (8비트 기준)
1. 양수 이진수로 변환 // 5 → 00000101
2. 1의 보수 계산 (비트 반전) // 00000101 → 11111010
3. 1 더하기 (2의 보수) // 11111010 + 1 → 11111011
11111011이 -5의 2의 보수 표현
왜 2의 보수를 쓰는 걸까?
- 덧셈과 뺄셈을 같은 회로로 처리 가능
- 0이 유일하게 표현됨 (1의 보수는 +0과 -0이 있음)
- 오버플로우 처리가 간단함
```
- Byte에는 toBinaryString() 메서드가 없다.
- byte는 보통 int로 자동 변환해서 처리됨
- 이진 표현이 필요한 경우는 대부분 int 이상에서 발생
- 인코딩 디코딩 특정 Charset으로: 지원하는 경우만 가능
- 인코딩 디코딩 다른 Charset으로: (확장 등) 호환되는 경우만 가능
- `public int read() throws IOException`
- InputStream.read()는 한 바이트를 읽는다.
- 그런데 왜 int를 반환할까