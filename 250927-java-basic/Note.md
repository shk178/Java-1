- 클래스 = 사용자 정의 타입이다.
- 클래스에 정의한 변수들을 멤버 변수=필드라 한다.
- 객체=인스턴스 = 클래스를 사용해 실제 메모리에 만들어진 실체
- new Student();로 실제 메모리에 만들고 참조 주소 반환한다.
- Student student1 =이 참조값(2f4d3709) 보관한다.
- student1 출력하면 class1.Student@2f4d3709가 나온다.
- class1.Student는 패키지.클래스 정보다.
- 클래스는 객체를 생성하기 위한 틀=설계도이다.
- 클래스는 객체가 가지는 속성(변수), 기능(메서드)를 정의한다.
- 객체는 실체이고 서로 독립적인 상태를 가진다. (서로 다른 객체)
- 인스턴스는 특정 클래스로부터 생성된 객체를 말한다.
- s1 객체는 S클래스의 인스턴스다. 라고 관계 강조할 때 사용한다.
- ctrl + space: 자동 완성 단축키
- students[2] 출력: null //클래스 배열에 객체 할당 안 하면 참조값 null
- students[0] = student1; //인스턴스 복사가 아니라 참조값 복사다.
- 모든 Java 클래스는 자동으로 Object 클래스를 상속받는다.
- public String toString() //Object 클래스의 메서드. 객체를 문자열로 표현 시 호출된다.
- getClass().getName() + "@" + Integer.toHexString(hashCode()) // 기본 구현
- System.out.println(someObject); -> someObject.toString(); 값을 출력
- Java에서는 메모리 주소에 직접 접근할 수 없고, 변수명을 통해 간접적으로 접근
- 실제 변수명이 아니라 toString() 출력에서 얻은 참조값이기 때문에, 코드 상에서 접근 불가
- public int hashCode() //Object 클래스에 있는 메서드. 객체의 해시값을 반환
- 메모리 주소: JVM 내부에서 객체가 실제로 존재하는 위치 (개발자가 직접 접근할 수 없음)
- 해시코드: 객체를 식별하기 위한 숫자 (논리적인 ID 역할)
- student1 출력: class1.Student@2f4d3709
- students[0] 출력: class1.Student@2f4d3709
- students 출력: [Lclass1.Student;@7291c18f
- toHexString으로 16진수 표시하니까 주소처럼 보이지만 아니다. 주소는 JVM 내부에서 관리된다.
- Student student1 = {"학생1", 1, 2}; //안 된다.
- Java는 객체 생성 시 반드시 클래스의 생성자를 호출해야 한다.
- 중괄호 {}는 배열이나 컬렉션 초기화에만 사용 가능
- new도 필요하다. new는 배열 선언&초기화, 프레임워크 자동 바인딩에서만 생략 시 자동 사용
- Student student1 = new Student("학생1", 1, 2); //된다.
- required: no arguments, found: java.lang.String,int,int //컴파일 오류
- 클래스에 생성자를 정의하지 않으면 기본 생성자 public Student() {}만 생성된다.
- 클래스에 생성자를 정의하면, 기본 생성자를 만들지 않는다. (호출 시 컴파일 오류)
- 기본형은 소문자로 시작, 참조형은 대문자로 시작한다.
- 기본형: int, double, char, boolean, byte, short, long, float
- 기본형: 값을 변수에 담고 바로 사용. 기본형은 성능이 좋다.
- 기본형: 객체가 아니다. 즉, Object를 상속받지 않는다.
- int a = 5;
- System.out.println(a instanceof Object); //컴파일 에러
- 기본형: new로 생성할 수 없고, 메서드를 가질 수 없다.
- 기본형: 지역 변수 등 스택에 저장되는 경우가 많다.
- 기본형: 객체로 쓰고 싶을 때 Wrapper Class를 사용한다. (박싱이라고 한다.)
- 참조형: 클래스(사용자 정의 객체), 배열, 인터페이스/추상클래스, String 등
- 참조형: 참조값을 저장하며, 참조값을 연산할 수 없다.
- 참조형: 배열도 여러 값을 담는 객체다.
- 참조형: Object를 상속받고, new가 동작하고, 힙 메모리에 객체로 저장된다.
- int[] numbers = {1, 2, 3};
- System.out.println(numbers instanceof Object); //true
- System.out.println(numbers.getClass()); //class [I
- 참조형: String도 Object를 상속한 클래스다.
- 참조형: 문자열 리터럴이 String Constant Pool에 저장된다.
- String name = "이름"; -> new String("이름");과 유사함 (Pool로 성능 최적화)
- 참조형: String은 자바에서 자주 쓰여서, + 연산 가능하고 자동 toString() 호출된다.
- 참조형: String도 Object를 상속한 클래스다.
- 참조형: String은 불변 객체(immutable) 라서 한 번 만들면 수정되지 않는다.
- 참조형: "abc" == "abc" → true, 같은 리터럴은 JVM이 공유함
- 참조형: new String("abc")와 "abc"는 == 비교 시 false 될 수도 있다.
- Data a = new Data();, Data b = a;
- a = ref.Data@27973e9b, b = ref.Data@27973e9b // a와 b는 동일한 객체를 참조
- a.value와 b.value는 같은 메모리 공간의 데이터를 읽고 쓴다. (a.value == b.value)
- 메서드: 호출할 때 사용하는 매개변수도 변수다. 매개변수의 값도 복사해서 전달한다.
- 메서드에 참조형을 전달하고 메서드에서 값을 변경하면 반영된다.
- 메서드에 기본형을 전달하고 메서드에서 값을 변경하면 반영되지 않는다.
- 변수: 멤버 변수(필드, 클래스에 선언), 지역 변수(메서드에 선언, 매개변수도 지역 변수)
- Student student1; //student1은 지역 변수다.
- 지역 변수는 수동 초기화
- 멤버 변수는 자동 초기화 //숫자 = 0, boolean = false, 참조형 = null
- null은 참조할 대상이 없다는 의미
- Data x = new Data();, x = null;
- System.out.println(x); //null
- System.out.println(x.value); //런타임 오류 NullPointerException
- new Data();로 만들었던 Data 인스턴스는 JVM의 GC가 정리한다.
- x = ref.Data@312b1dae; <- 이렇게는 안 된다.
- 지역 변수는 null 여부가 명확하게 보인다.
- Data x = null;도 지역 변수다.
- 지역 변수는 메서드 안에서만 존재, 초기화 위치가 바로 보이기 때문
- 멤버 변수는 언제 null인지 추적이 어렵다.
- BigData a = new BigData();
- a.data //null, data는 Data data;라는 BigData의 멤버 변수
- class BigData { Data data; } //멤버 변수 선언만 하고, 객체 안 만듦
- a.data.value //NullPointerException
- class BigData2 { Data data = new Data(); } //객체의 변수 초기화됨
- BigData2 b = new BigData2();
- b.data.value //0
- BigData2 b = new BigData(); //컴파일 오류
- ProductOrder[] orders = new ProductOrder[n];
- orders[i].name = "이름"; //NullPointerException
- ProductOrder 객체를 n개 생성한 게 아니라, 참조 변수 n개인 배열 만든 거다.
- orders = [null, null, null, ...]처럼 배열 요소들이 초기값 상태로 존재한다.
- for (ProductOrder o : orders) { o = new ProductOrder(); } //배열 안 바뀐다.
- ProductOrder o는 for-each 반복 중 한 번씩 새로 만들어지는 지역 변수다.
- 반복마다 orders[i] 값인 null을 복사해서 o에 저장한다.
- o가 가리키는 참조는 새로운 객체를 만들어도 배열에는 영향을 주지 않는다.
- orders[i] = new ProductOrder();처럼 orders[i]에 직접 할당하게 할 수 있다.
- orders[i] = createOrder(a, b, c);처럼 메서드에서 객체 생성 및 반환하게 할 수 있다.
- for (ProductOrder o : orders) { o.name = "1"; } //객체의 name이 "1"로 바뀐다.
- 반복마다 orders[i] 값을 복사해서 지역 변수 o에 저장하는 건 같다.
- o가 가리키는 참조와 .(dot)으로 객체의 멤버 변수에 접근한 것이어서 바뀐다.
- 배열의 orders[i] 값에는 변화가 없다.
- 즉, NullPointerException은 null 값을 가진 참조 변수로 멤버 접근 시 발생한다.
- f2: 다음 오류로 이동하는 단축키
- 클래스 메서드: static 있다. 객체 필요 없이 클래스 이름으로 바로 호출 가능하다. Math.abs();
- 인스턴스 메서드: static 없다. 객체 필요하다. input.nextInt();
- main 함수 안에서 사용하는 static 메서드는 클래스 메서드이다.
- 클래스 메서드 = 정적 메서드이다. 객체(인스턴스) 없이 호출 가능하다.
- main 함수 자체도 static이라서 같은 레벨의 static 메서드만 직접 호출 가능하다.
- Java 프로그램은 클래스가 실행될 때 아직 객체가 없는 상태에서 시작되므로,
- JVM이 클래스 이름만 보고 실행할 수 있도록 static 메인 함수가 필요하다.
- 클래스가 메모리에 올라가자마자 객체 없이도 호출 가능 = static이 필수다.
- JAVA는 메서드 안에 또 다른 메서드를 정의할 수 없다. //컴파일 오류
- main 함수가 사용하는 static 메서드: 같은 클래스는 메서드 이름으로 호출
- main 함수가 사용하는 static 메서드: 다른 클래스는 클래스명.메서드명으로 호출
- 객체 지향은 모든 사물을 속성과 기능을 가진 객체로 생각하는 것이다.
- 실세계와 객체가 항상 1:1로 매칭되지는 않는다.
- 캡슐화: 객체의 속성(데이터)과 그 속성을 다루는 기능(메서드)을 하나로 묶어서 관리
- 자동 생성되는 기본 생성자는 디컴파일에서 안 보인다.
- 그래도 컴파일러가 public MemberInit() {}처럼 클래스 안에 기본 생성자 만든다.
- 객체 메서드에서 멤버 변수도 있고, 매개변수도 있다. 둘의 이름이 같을 수 있다.
- 같으면 매개변수로 우선 접근하게 된다. 이때 멤버 변수를 지칭하려면 this.를 붙인다.
- 이름이 같은데 this.를 안 붙이고 age = age; 하면 멤버 변수 age에는 적용이 안 된다.
- 생성자의 이름은 클래스와 같아야 한다. 첫 글자를 대문자로 시작한다.
- 생성자는 반환 타입이 없다. void도 안 적는다. 나머지는 메서드와 같다.
- new MemberInit(); //()는 생성자를 호출한다는 의미이다.
- 생성자를 메서드 오버로딩처럼 여러 개 정의할 수 있다. //다른 거 호출하면 컴파일 오류
- MemberConstruct(String name, int age, int grade) {
- this.name = name; this.age = age; this.grade = grade; }
- MemberConstruct(String name, int age) { this(name, age, 50); }
- 생성자 체이닝이라고 한다.
- this();는 객체 지칭이 아닌 명령어 역할(생성자 위임)이다.
- this();는 생성자 내부에서만, 가장 첫 줄에서만 쓸 수 있다.
- 다른 상황에서 (생성자 기타 상황, 메서드) this.는 현재 객체 자신을 가리키는 참조값이다.
- 다른 패키지에서 클래스의 생성자를 호출하려면 public 생성자여야 한다.
- pack에 Data 클래스가, pack.a에 User 클래스가 있다.
- pack에 PackMain에서 Data, User 생성자 호출하려면 import pack.a.User; 입력해야 한다.
- import a.User;은 안 된다.
- import 대신 pack.a.User user2 = new pack.a.User();처럼 써도 된다.
- import를 사용하면 다른 패키지에 있는 클래스를 쓸 수 있다.
- 특정 패키지에 포함된 모든 클래스를 사용하려면 import pack.a.*;처럼 쓰면 된다.
- PackMain에서 import pack.*; 쓴다고 해서 pack.a.User를 쓸 수 없다.
- PackMain2는 pack.a의 클래스라면, import pack.*; 해서 pack.Data 쓸 수 있다.
- pack과 pack.a의 상위-하위 구분은 없다. 서로 다른 패키지이다.
- 디렉터리 구조는 상위-하위지만, Java 컴파일러나 JVM 입장에서 별도의 패키지이다.
- 클래스 구분은 패키지+클래스 이름으로 (전체 경로로) 한다.
- SameName이 pack, pack.a, pack.b에 있다고 하자.
- pack.a의 PackMain2에서 pack을 import한다. pack.a.SameName이 우선 호출된다.
- BExample이 pack, pack.b에 있다고 하자.
- pack.a의 PackMain2에서 둘 다 *로 import한다. ambiguous 컴파일 오류 난다.
- 보통은 자주 사용하는 클래스의 패키지를 import하고 나머지는 명시한다.
- 패키지 이름 모두 소문자 (대소문자 구분 안 하는 os가 있다.)
- 패키지 이름 앞 부분에는 보통 회사 도메인 이름을 거꾸로 사용
- com.helloshop.user: User, UserService
- com.helloshop.product: Product, ProductService
- com.helloshop.order: Order, OrderService, OrderHistory
- Order는 com.helloshop.product.Product, com.helloshop.user.User를 import한다.
---
- volume 필드를 Speaker2 클래스 외부에서 접근하지 못하도록 한다.
- private으로 선언한다. SpeakerMain2에서 .volume 하면 컴파일 오류 난다.
- private: 같은 클래스 내부에서만 접근 가능하다. 다른 클래스에서는 접근할 수 없다.
- (default): 접근 제어자를 명시하지 않으면, 같은 패키지 내에서는 접근이 가능하다.
- default = package-private
- protected: 같은 패키지 내에서는 접근 가능하며, 다른 패키지에서는 상속을 받은 경우에만 접근이 가능하다.
- 상속을 받은 경우 = 하위 클래스
- public: 모든 패키지, 모든 클래스에서 접근이 가능하다.
- 필드 접근 제어자: 객체의 속성 값에 대한 접근 제한
- 메서드 접근 제어자: 객체의 기능에 대한 접근 제한
- 생성자 접근 제어자: 객체의 생성 방법에 대한 접근 제한
- 클래스 접근 제어자: 클래스 자체에 대한 접근 제한
- private, protected는 상속이나 내부 접근 제어에 중점을 둔 제어자이다.
- Top-level 클래스에는 public 또는 default만 허용된다.
- 생성자 접근 제어하는 이유: private으로 클래스 내부에서만 객체 생성하도록 하기 위해
- 생성자 접근 제어하는 이유: public static 메서드로 private 생성자를 호출해, 생성 방식을 통제하기 위해
- private 생성자 호출 전에는 인스턴스가 없어서, 클래스 이름.메서드 이름으로 메서드 호출하기 위해 static을 사용한다.
- 생성자 접근 제어하는 이유: protected으로 상속을 통해서만 생성하도록 하기 위해
- 클래스 접근 제어하는 이유: public으로 모든 곳에서 사용할 수 있도록 하기 위해
- 외부에서 직접 사용하거나, 라이브러리의 공개 API로 제공되는 클래스는 public이어야 한다.
- 공개 API - 다른 프로그램이 직접 사용하도록 설계된 기능이나 클래스를 말한다.
- 공개 API - 예: ArrayList, HashMap, Scanner 등
- 클래스 접근 제어하는 이유: default로 같은 패키지에서만 사용할 수 있도록 하기 위해
- 내부 구현 전용 클래스, 라이브러리 외부에 노출되면 안 되는 유틸 클래스는 default로 쓴다.
- 내부 구현 전용 - 외부에서는 사용할 필요 없는, 클래스 내부 동작을 돕는 보조 클래스
- 내부 구현 전용 - 라이브러리 사용자가 헷갈리지 않게, 외부에서 잘못 사용 방지하기 위해
- 내부 구현 전용 - 클래스 default
- 유틸 클래스 - 여러 클래스에서 공통으로 사용할 수 있는 재사용 가능한 기능 모음 클래스
- 유틸 클래스 - 인스턴스 생성할 필요 없이 static 메서드만 있고, 상태x 기능 중심
- 유틸 클래스 - 예: java.lang.Math, Collections, Arrays 등 (클래스 public, 생성자 private)
- 유틸 클래스 - 패키지 내부 전용 유틸 클래스일 때 클래스 default, 생성자 private
- Top-level 클래스: 가장 바깥족에 선언된 클래스로서 다른 클래스 안에 포함되지 않은, 독립된 클래스이다.
- .java 파일 안에 Top-level 여러 개 선언할 수 있지만, 그중 public 클래스는 하나고 파일명=클래스명이다.
- 나머지 Top-level 클래스에는 default를 쓴다.
- protected: 같은 패키지나 다른 패키지의 하위 클래스에서만 접근 가능하다.
- Top-level 클래스는 패키지 단위로 접근 제어되기 때문에, 패키지 밖에서 쓸 수 있는가/없는가가 기준이다.
- Top-level 클래스는 하위 클래스를 가질 수 없다. 하위 클래스는 클래스 내부가 아니라 밖에 정의된다.
- protected는 멤버(필드/메서드)와 중첩 클래스 전용 설계다. (클래스 간 관계보다 멤버 간 상속, 접근에 적합)
- Nested 클래스: 클래스 안에 선언된 클래스이다.
- static이 붙는지 여부에 따라 Static Nested와 Inner 클래스로 나뉜다.
- Nested 클래스에는 모든 접근 제어자를 사용할 수 있다.
- Nested 클래스에 public을 사용하려면, 바깥 클래스가 public일 경우에만 된다.
- Nested 클래스를 private으로 하면, 바깥 클래스가 아닌 Top-level 클래스에서는 접근이 안 된다.
- Nested 클래스는 바깥 클래스의 메서드나 필드와 다르다.
- 메서드는 메모리 코드 영역에 저장되고, 필드는 인스턴스 or static 메모리에 저장된다.
- Nested 클래스는 새로운 타입을 정의하는 역할이고, 컴파일 시 $.class 파일로 따로 생긴다.
- Nested 클래스는 인터페이스 구현, 상속, 제네릭 타입 등에도 사용 가능하다.
- import: 접근 권한이 아니라, 이름을 알려주는 선언이다.
- 컴파일러는 다른 패키지에 있는 클래스의 전체 경로(FQCN)를 모르면 에러를 낸다.
- 상속을 하든, 객체를 생성하든, 다른 패키지의 클래스를 사용하려면 import가 필요하다.
- import를 하더라도 public으로 선언된 때만 다른 패키지에서 사용할 수 있다.
- 파일명=클래스명인 Top-level 클래스를 default로 선언할 수도 있다.
- 그러면 같은 package에서만 쓸 수 있다. 다른 package에서는 import하면 컴파일 오류 난다.
- AccessClass.java에서 생성자를 default로 하면, public 클래스여서 access.b에서 import는 된다.
- 하지만 생성자가 default여서 객체 생성이 안 된다.
- 캡슐화를 안전하게 완성해주는 장치가 접근 제어자다.
- 데이터를 숨기고 메서드를 통해 접근하도록 한다.
- 기능 중 외부에서 사용하지 않는 내부 기능은 숨긴다.
- generate 단축키: alt + insert
- 자바 메모리 구조: 메서드 영역 + 스택 영역 + 힙 영역
- 메서드 영역: 클래스 정보를 보관, 붕어빵 틀
- 스택 영역: 실제 프로그램 실행되는 영역, 메서드 실행마다 하나씩 쌓인다.
- 힙 영역: 객체(인스턴스)가 생성되는 영역, new -> 붕어빵 틀로부터 붕어빵을 생성해낸다. 배열도 저장된다.
- 메서드 영역은 프로그램 실행에 필요한 공통 데이터를 관리한다. 프로그램의 모든 영역에서 공유한다.
- 메서드 영역: 클래스 정보 + static 영역 + 런타임 상수 풀
- 클래스 정보 - 클래스 이름, 인터페이스 정보, 필드/메서드 정보 (static 포함), 생성자 정보, 메서드의 바이트코드
- static 영역 - static 변수의 실제 값이 저장됨
- 런타임 상수 풀 - 리터럴 상수("abc" 등), 컴파일 타임 상수(final static 값), 심볼 정보(메서드/필드 이름, 타입 등)
- 스택 영역-스택 프레임: 각 thread에 하나씩 생성됨. 지역 변수 + 중간 연산 결과 + 메서드 호출 정보 등
- 자바 실행 시 main() frame 생성된다. 메서드 호출할 때마다 스텍 프레임 추가되고 메서드 종료 시 제거된다.
- 힙 영역은 객체(인스턴스)와 배열이 생성되는 영역으로, GC가 이루어지는 주요 영역이다.
- 자바에서 특정 클래스로 100개의 인스턴스를 생성하면, 힙 메모리에 100개의 인스턴스가 생긴다.
- 같은 클래스로부터 생성된 인스턴스라도, 내부의 변수 값은 서로 다를 수 있지만, 메서드는 코드를 공유한다.
- 인스턴스 생성 시, 인스턴스 변수에 힙 메모리가 할당된다. 메서드 호출 시, 메서드 영역의 코드를 불러와서 수행한다.
- 스택 자료구조: Last In First Out (후입 선출)
- 큐 자료구조: First In First Out (선입 선출)
- extended selection 단축키: ctrl + w
- main() 스택 프레임: args[]라는 매개변수를 가진다. 매개변수도 지역 변수이므로 스택 프레임에 포함된다.
- method1() 스택 프레임 -> method2() 스택 프레임 생성
- method2() 종료 후, method1()의 다음 코드가 실행된다.
- 메서드 만들거나, 노란줄 고치는 단축키: alt + 엔터
- JavaMemoryMain2.java에서, method1()은 지역 변수로 Data data1을 가지고 있다.
- Data data1은 스택 프레임에 포함된다. method1()은 new Data(10);으로 힙 영역에 Data 인스턴스 생성한다.
- Data 인스턴스의 참조값이 data1에 저장된다. 스택 프레임이 제거되면 참조x, Data 인스턴스는 GC 처리된다.
- static 키워드를 사용하면 클래스의 인스턴스들이 공유하는 변수를 만들 수 있다.
- static 멤버 변수를 클래스 변수라고 하고, static이 붙지 않은 멤버 변수를 인스턴스 변수라고 한다.
- 지역 변수(매개변수 포함)는 메서드가 실행될 때 스택 영역에 저장되어, 메서드 종료까지 유지된다.
- 인스턴스 변수는 인스턴스가 생성될 때 힙 영역에 저장되어, 인스턴스가 참조되지 않을 때까지 유지된다.
- static 멤버 변수는 클래스가 처음 로딩될 때 메서드 영역에 저장되어, 프로그램 종료까지 유지된다.
- static 메서드는 클래스가 처음 로딩될 때 메서드 영역에 저장되고, 인스턴스 메서드는 객체 생성될 때 메서드 영역에 저장된다.
- JVM은 클래스를 필요할 때 로드하고, 거의 대부분 프로그램이 종료될 때까지 언로드하지 않는다. (메서드들이 유지된다.)
- static 변수나 메서드는 인스턴스 소속이 아닌 클래스 소속이다. 인스턴스 생성 없이 클래스 이름.으로 바로 사용할 수 있다.
- this.나 인스턴스 이름.으로도 접근이 되지만, static 메서드 내에서는 안 된다.
- static 메서드를 인스턴스 참조값 없이 호출하기 때문이다. static 메서드 내에서 this.를 사용할 수 없다.
- static 메서드에서 인스턴스 변수에 접근하거나 인스턴스 메서드를 호출할 수 없고, 정적 변수와 정적 메서드만 사용할 수 있다.
- static 메서드 매개변수로 인스턴스 참조값을 전달한다면 사용 가능하다.
- 제약과는 반대로, static 메서드는 클래스의 공용 기능이다. 접근 제어자만 허락하면 모든 곳에서 static을 호출할 수 있다.
- 인스턴스 메서드, 클래스 (static) 메서드를 멤버 메서드라고 한다.
- 클래스 메서드는 객체 생성 없이 필요한 기능 수행 시 사용한다. 예: 유틸리티성 메서드 (수학 클래스 메서드들)
- 객체 생성을 막으려면 클래스 생성자를 private로 설정하면 된다.
- static import: 다른 클래스의 static 멤버(변수, 메서드)를 클래스 이름 없이 직접 사용할 때
- import 패키지명.클래스명; 하면 static 멤버를 쓸 때 클래스명.멤버명으로 접근한다.
- import static 패키지명.클래스명.*; 하면 멤버명으로 바로 쓸 수 있다.
- main() 메서드도 정적 메서드여서, main()이 같은 클래스에서 호출하는 메서드도 static으로 선언해서 사용한다.
- final 지역 변수: 값을 한 번만 할당 가능하다. 매개변수에 final을 쓰면 메서드에서 값을 못 바꾼다.
- final 인스턴스 변수: 선언과 동시에 또는 생성자를 통한 초기화 한 번만 가능하다. 이후에 값을 못 바꾼다.
- static final 변수: 선언과 동시에 초기화만 가능하다. 이것을 "상수"라고 부르고 이름을 대문자로 쓴다.
- 선언과 동시에 초기화는 static final로 메서드 영역에 하나만 만드는 게 낫다.
- 힙 영역에는 인스턴스 변수 + 참조 중인 객체 + 배열 객체 자체가 저장된다.
- static 메서드, 인스턴스 메서드는 메서드 영역에 저장된다.
- "hello"라는 리터럴 문자열은 런타임 상수 풀에 저장된다.
- String name = "hello";가 메소드에서 선언됐다면 String name은 스택 영역에 있다. 클래스 멤버라면 힙에 있다.
- static final 키워드를 사용한 자바 상수: 하나만 존재하고 고정된 값이다.
- 대문자를 사용하고 구분은 _(언더스코어)로 한다.
- public static final로 Constant.PI처럼 직접 접근해서 사용하도록 한다.
- static final은 매직 넘버 문제를 해결한다. 숫자 대신 변수명으로 코드를 이해할 수 있다.
- 상속: 기존 클래스의 속성과 기능을 물려받는다. extends 부모 클래스 이름을 사용하며, 1개만 extends할 수 있다.
- 다중 상속을 허용하면 다이아몬드 문제가 발생한다. (메서드 이름이 같을 때 문제) 인터페이스는 다중 구현을 허용한다.
- 클래스1 -> 클래스2 extends 클래스1 -> 클래스3 extends 클래스2: 클래스1과 클래스2를 클래스3이 물려받는다.
- 상속을 사용하면, 서브 클래스 인스턴스를 생성할 때 슈퍼 클래스도 함께 포함해서 생성된다. 참조값은 하나다.
- 호출한 메서드가 해당 클래스 타입에 있는지 찾고, 없으면 부모 클래스 타입에 있는지 찾는 순서로 실행한다.
- 부모 클래스의 메서드를 자식 클래스가 재정의하는 것을 메서드 오버라이딩이라고 한다. 앞줄에 @Override를 붙인다.
- @Override는 애노테이션이라고 한다. 프로그램이 읽을 수 있는 특별한 주석이다.
- 애노테이션이 없어도 동작한다. 애노테이션이 있으면 컴파일러가 오버라이딩이 안 됐을 때 오류를 내니까 쓴다.
- 메서드 오버로딩: 메서드 이름이 같고 패러미터가 다른 메서드를 여러 개 정의한다. 오버라이딩과 다르다.
- 메서드 오버라이딩 조건: 이름, 파라미터가 같고 반환 타입이 같아야 한다.
- 반환 타입이 하위 클래스 타입일 수도 있다.
- 메서드 오버라이딩 조건: 접근 제어자가 상위 클래스의 메서드보다 제한적이어서는 안 되고, 같거나 더 넓어야 한다.
- 상위 클래스에서 protected였다면, 재정의는 public/protected로만 된다. private/default로 할 수 없다.
- 상위 클래스의 메서드보다 적거나 같은 수의 예외, 또는 하위 타입의 예외만 throws로 선언할 수 있다.
- static, final, private 키워드가 붙은 메서드는 오버라이딩을 할 수 없다.
- static은 클래스에서 작동하는데 오버라이딩은 인스턴스에서 사용한다.
- final 메서드는 재정의를 금지한다.
- private 메서드는 해당 클래스에서만 접근 가능하므로 하위 클래스에서 보이지 않는다.
- Child로 생성한 인스턴스 내부에 Child와 Parent가 구분되어 있다.
- 서로 다른 패키지의 Child는 Parent의 public, protected 멤버에만 접근할 수 있다.
- 같은 패키지의 Child는 Parent의 public, protected, default 멤버에 접근할 수 있다.
- 부모-자식의 필드명이 같거나 메서드가 오버라이딩 되어 있을 때, super 키워드로 부모를 참조할 수 있다.
- 자식 내부에서만 super.필드와 super.메서드로 접근할 수 있다. (super.필드 값도 바꿀 수 있다.)
- Child를 생성하면 Child와 Parent의 생성자가 모두 호출된다. (생성자가 상속되는 건 아니다. 오버라이딩도 x)
- 이때 Child의 생성자에서 super(...)로 Parent의 생성자를 반드시 호출해야 한다.
- 호출하지 않아도 super();가 자동 실행되지만, Parent 생성자에 패러미터가 있으면 컴파일 에러 난다.
- Child에서 생성자 체이닝의 this(...)를 첫 줄에 썼다면 다음에 super(...)를 쓰도록 한다.
- 오버라이드 단축키: ctrl + o
- 클래스에 final을 붙이면 상속받을 수 없다. 메서드에 final을 붙이면 오버라이딩 할 수 없다.
---