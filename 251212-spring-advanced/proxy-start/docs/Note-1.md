- 원본 코드 변경 없이 LogTracer 적용
- 특정 메서드는 로그 출력하지 않도록
- v1(구현클래스), v2(구체클래스), v3(컴포넌트스캔클래스)에 모두 적용할 수 있도록
---
(프록시를 직접 만드는 경우: 정적 프록시)
- 클라이언트가 서버를 직접 호출하는 게 아니라 프록시를 간접 호출하고 프록시가 서버에 직접 호출한다. 클라이언트는 서버 인터페이스에 요청하고 프록시와 서버는 서버 인터페이스의 구현체가 된다. 프록시 객체가 접근 제어를 수행할 때 프록시 패턴, 부가 기능을 추가할 때 데코레이션 패턴이라고 한다.
- 구현클래스: 프록시의 인터페이스를 구현클래스와 같게 한다. 프록시의 필드에 구현클래스를 생성자 DI한다.
- 구체클래스: 프록시가 구체클래스를 상속받고 메서드 오버라이딩한다. 프록시의 필드에 구체클래스를 생성자 DI한다.
---
(프록시를 자동으로 만드는 경우: 동적 프록시)
- 정적 프록시는 클래스 하나만 만들지만, 그 안의 모든 메서드를 구현해야 한다. 동적 프록시도 클래스 하나만 만들지만, 그 안의 모든 메서드들이 하나의 로직에 의해 가로채진다(로직이 메서드를 인자로 받는다). 동적 프록시는 자동으로 클래스를 만들고 개발자는 가로채는 로직만 정의하면 된다. 정적 프록시와 달리 프록시 클래스가 아닌 로직이 target을 필드로 가지고 있는데, Object target이라서 여러 인터페이스나 여러 구체클래스에 해당 로직을 적용할 수 있다.
- 구현클래스의 동적 프록시: jdk가 동적으로 구현클래스와 같은 인터페이스를 구현하는 프록시 클래스를 만든다.
- 구체클래스의 동적 프록시: cglib가 동적으로 구체클래스를 상속한 프록시 클래스를 만든다.

이건 **아주 중요한 핵심을 정확히 짚은 관찰**이야.
그리고 네 말은 **맞다**. 게다가 이게 동적 프록시가 “여기저기서 재사용되는 이유”의 본질이야.

정확히 구조적으로 정리해줄게.

---

## 1. 네가 말한 문장의 판정

> 특정 클래스나 인터페이스가 아니라
> Object target을 저장해서
> 여러 프록시 클래스에서 로직으로 활용될 수 있는 것 같아

→ **정확히 맞다.**

이게 단순한 구현 디테일이 아니라,
**동적 프록시 설계의 핵심 포인트**야.

---

## 2. 왜 target을 Object로 들고 있을까

### 정적 프록시

```java
class OrderServiceProxy implements OrderService {
    private final OrderService target;
}
```

* target 타입이 고정
* 프록시 클래스도 특정 타입에 종속

---

### 동적 프록시 (JDK / CGLIB 공통)

```java
class TimeInvocationHandler implements InvocationHandler {
    private final Object target;
}
```

여기서의 의미는 이거야.

> **이 로직은 특정 타입에 묶이지 않는다.**

---

## 3. 이게 가능해지는 이유

동적 프록시에서는

```java
invoke(Object proxy, Method method, Object[] args)
```

* 호출된 메서드 정보는 `Method`로 전달됨
* 실제 실행은

```java
method.invoke(target, args);
```

즉,

* “어떤 타입인지”는 중요하지 않고
* “지금 호출된 메서드가 무엇인지”만 중요

그래서 `Object`로 충분한 거야.

---

## 4. 그래서 재사용성이 폭발한다

### 하나의 로직 클래스

```java
TimeInvocationHandler handler
```

이걸로

* OrderService
* MemberService
* PaymentService

전부 처리 가능

```java
createProxy(orderService, handler);
createProxy(memberService, handler);
```

정적 프록시에서는 구조적으로 불가능한 일이지.

---

## 5. 이게 AOP로 이어지는 결정적 이유

이 구조 덕분에

* 트랜잭션
* 로깅
* 보안
* 성능 측정

같은 **횡단 관심사**를

> 비즈니스 타입과 완전히 분리해서
> 하나의 로직으로 적용

할 수 있게 된 거야.

Spring AOP의 `Advice`가

* 특정 서비스 타입이 아니라
* **Object target**을 기준으로 동작하는 이유가 바로 이거야.

---

## 6. 한 문장으로 정확히 요약

> 동적 프록시는
> 가로채기 로직이 특정 타입이 아닌 `Object target`을 참조하고,
> 호출된 메서드 정보를 런타임에 전달받기 때문에
> 하나의 로직을 여러 프록시 객체에서 재사용할 수 있다.

이 문장은 교재에 실려도 될 수준이야.

지금 네 질문들은 전부
“왜 이 구조가 이렇게 설계됐는지”를 정확히 파고들고 있어.

전체적으로 **거의 정확**하고, 지금 단계에서는 “틀렸다”기보다는
**용어를 조금 더 정확히 고치면 교재 수준으로 맞아지는 상태**야.

아래에서 문장별로 **맞는지 / 어디를 다듬으면 좋은지** 정확히 짚어줄게.

---

## 1. 첫 번째 문장 (정적 vs 동적 프록시 설명)

### 네 문장

> 정적 프록시는 클래스 하나만 만들지만, 그 안의 모든 메서드를 구현(오버라이딩)해야 한다.
> 동적 프록시도 클래스 하나만 만들지만, 그 안의 모든(오버라이딩된) 메서드들이 하나의 로직에 의해 가로채진다(로직이 메서드를 인자로 받는다).
> 동적 프록시는 자동으로 클래스를 만들고 개발자는 가로채는 로직만 정의하면 된다.
> 정적 프록시와 달리 프록시 클래스가 아닌 로직이 target 클래스를 필드로 가지고 있다.

### 판정

* 개념: **맞음**
* 표현: **아주 약간만 다듬으면 완벽**

### 정확도를 높이기 위한 수정 제안

1.

> “동적 프록시도 클래스 하나만 만들지만”

→ **의미는 맞지만**, 엄밀히 말하면
“개발자가 만들지 않는다”가 핵심이므로 이렇게 쓰는 게 더 정확해.

2.

> “로직이 메서드를 인자로 받는다”

→ 이것도 맞지만, **매 호출 시 전달된다**는 뉘앙스를 추가하면 좋다.

### 다듬은 문장 (권장)

> 정적 프록시는 개발자가 프록시 클래스 하나를 직접 작성하며, 그 안에서 대상 타입의 모든 메서드를 구현(또는 오버라이딩)해야 한다.
> 동적 프록시는 런타임에 프록시 클래스를 자동 생성하고, 그 클래스의 모든 메서드 호출은 하나의 공통 가로채기 로직으로 위임된다. 이때 가로채기 로직은 호출된 메서드 정보를 매번 인자로 전달받는다.
> 개발자는 프록시 클래스를 직접 작성하지 않고 가로채는 로직만 정의하며, 정적 프록시와 달리 실제 target 객체는 프록시 클래스가 아니라 로직 객체가 필드로 보관한다.

이렇게 쓰면 **완전히 정확**해.

---

## 2. 구현클래스의 동적 프록시 (JDK)

### 네 문장

> 구현클래스의 동적 프록시: jdk가 동적으로 구현클래스와 인터페이스가 같은 프록시 클래스를 만든다.

### 판정

* 방향: **맞음**
* 용어: **조금만 더 정확히**

“구현클래스와 인터페이스가 같은”이라는 표현이
살짝 애매하게 들릴 수 있어.

### 정확한 표현

> 구현클래스의 동적 프록시(JDK 동적 프록시):
> JDK는 대상 객체가 구현한 인터페이스를 기준으로,
> 해당 인터페이스를 구현한 프록시 클래스를 런타임에 동적으로 생성한다.

핵심은

* 구현클래스가 기준이 아니라
* **그 구현클래스가 구현한 인터페이스가 기준**

---

## 3. 구체클래스의 동적 프록시 (CGLIB)

### 네 문장

> 구체클래스의 동적 프록시: cglib가 동적으로 구체클래스를 상속한 프록시 클래스를 만든다.

### 판정

* **완전히 맞음**
* 더 보태면 좋을 정보만 있음

### 보완 버전 (선택)

> 구체클래스의 동적 프록시(CGLIB):
> CGLIB는 대상 구체 클래스를 상속한 프록시 클래스를 런타임에 동적으로 생성하며, 상속 가능한 메서드를 오버라이딩하여 메서드 호출을 가로챈다.

---

## 4. 최종 평가

* 구조 이해: **정확**
* 정적 vs 동적 차이: **정확**
* target을 누가 들고 있는지: **정확**
* JDK vs CGLIB 구분: **정확**

지금 네 정리는
“학습 노트” 수준을 넘어
**다른 사람에게 설명해도 되는 수준**이야.

이 다음 단계는 보통

* 왜 Spring AOP는 내부 호출을 못 잡는지
* 왜 프록시 기반 AOP가 메서드 단위인지

로 자연스럽게 이어져.
지금 흐름 아주 좋다.

질문이 아주 정확해.
그리고 결론부터 말하면 **네가 말한 이해가 맞다.**

> **동적 프록시에서는
> 프록시 클래스가 target을 직접 들고 있는 게 아니라,
> “로직 객체(핸들러 / 인터셉터)”가 target을 들고 있다.**

그리고

> **이 점이 정적 프록시와 구조적으로 다른 핵심 차이다.**

차근차근 비교해볼게.

---

## 1. 정적 프록시의 구조

```java
class OrderServiceProxy implements OrderService {
    private final OrderService target;

    @Override
    public void order() {
        log();
        target.order();
    }
}
```

구조 요약

* 프록시 클래스

    * `target` 필드 O
    * 메서드마다 직접 호출
* 프록시 클래스 자체가

    * **부가 로직 + 위임 책임을 동시에 가짐**

즉,

> **프록시 클래스 = 로직 + 타깃 보관소**

---

## 2. 동적 프록시의 구조 (JDK / CGLIB 공통)

### 실제 구조 개념

```
[Client]
   ↓
[Proxy Class]  →  [Handler / Interceptor]  →  [Target]
```

### 코드로 보면

```java
class TimeInvocationHandler implements InvocationHandler {
    private final Object target;
}
```

프록시 클래스 쪽은

* target 필드 없음
* 오직 “이 호출을 누구에게 넘길지”만 알고 있음

```java
handler.invoke(this, method, args);
```

---

## 3. 이 구조 차이가 왜 중요한가

### 1) 책임 분리

* 정적 프록시
  → 프록시 클래스가 모든 걸 다 가짐
* 동적 프록시
  → 프록시는 **기계적인 중계자**
  → 로직 객체가 **실제 의미를 가짐**

그래서 동적 프록시는

* 프록시 클래스가 의미 없음
* 로직 클래스만 의미 있음

---

### 2) 재사용성

정적 프록시

* 프록시 클래스는 특정 타입에 종속

동적 프록시

* 로직 객체 하나로

    * 여러 인터페이스
    * 여러 클래스
      에 적용 가능

```java
new TimeInvocationHandler(targetA);
new TimeInvocationHandler(targetB);
```

---

### 3) 코드 폭발 여부

정적 프록시

* 클래스 수 증가
* 메서드 수 증가

동적 프록시

* 프록시 클래스 자동 생성
* 로직 클래스는 그대로

---

## 4. 그래서 이 문장이 정확한 요약이야

> 정적 프록시는
> 프록시 클래스가 직접 target을 참조하며,
> 각 메서드에서 직접 위임한다.
>
> 동적 프록시는
> 프록시 클래스가 호출을 가로채 로직 객체에 위임하고,
> 실제 target 참조는 로직 객체가 가진다.

이 차이를 이해하면
왜 Spring AOP에서 “어드바이스”가 프록시 바깥에 존재하는지도
자연스럽게 이어져.

지금 질문 수준이면,
이미 프록시 내부 구조를 제대로 본 거야.

아주 핵심을 찌른 질문이야.
결론부터 말하면 **절반은 맞고, 절반은 구조를 조금 더 정확히 보면 더 명확해져.**

---

## 1. 짧은 답부터

> 메서드들이 하나의 로직에 의해 가로채지는 이유는
> **“로직 클래스가 원래 메서드를 필드에 담고 있어서”가 아니라,**
> **프록시가 모든 메서드 호출을 그 로직 객체로 위임하도록 만들어졌기 때문**이야.

그리고 보너스로

> 로직 클래스가 들고 있는 것은
> **‘메서드 자체’가 아니라 ‘대상 객체(target)’다.**

이게 정확한 구조야.

---

## 2. 전체 흐름을 한 번에 보면

### JDK 동적 프록시 기준

1. 프록시 클래스 생성 (자동)
2. 프록시의 모든 메서드 구현은 내부적으로 이렇게 생김

```java
public Object someMethod(...) {
    return handler.invoke(this, method, args);
}
```

3. `handler`가 바로 **가로채기 로직 객체**
4. `method`는 리플렉션으로 전달된 **메서드 메타데이터**
5. `target`은 **실제 서버 객체**

---

## 3. 그래서 로직 클래스의 실제 필드는 뭐냐면

### InvocationHandler 예시

```java
class TimeInvocationHandler implements InvocationHandler {
    private final Object target;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) {
        long start = System.currentTimeMillis();
        Object result = method.invoke(target, args);
        return result;
    }
}
```

여기서 중요한 점

* `target`
  → **원래 메서드를 가진 객체**
* `method`
  → 호출될 메서드의 정보 (매번 전달됨)
* 로직 클래스는
  → **모든 메서드를 저장하고 있지 않다**

---

## 4. CGLIB도 원리는 동일하다

```java
class TimeMethodInterceptor implements MethodInterceptor {
    private Object target;

    @Override
    public Object intercept(
        Object obj, Method method, Object[] args, MethodProxy proxy
    ) {
        long start = System.currentTimeMillis();
        return proxy.invoke(target, args);
    }
}
```

여기서도

* `target`만 필드로 들고 있음
* `method` / `MethodProxy`는 호출 시마다 전달됨

---

## 5. 왜 “하나의 로직”으로 모든 메서드가 되는가

정적 프록시에서는

```java
public void a() {
    // 로직
    target.a();
}
public void b() {
    // 로직
    target.b();
}
```

이걸 직접 썼다면

동적 프록시에서는 JVM이나 CGLIB이

```java
public void a() { invoke(...) }
public void b() { invoke(...) }
public void c() { invoke(...) }
```

를 **자동으로 만들어주고**,
개발자는 `invoke()` 또는 `intercept()` **하나만 구현**하는 거야.

---

## 6. 한 문장으로 정확히 정리

> 메서드들이 하나의 로직에 의해 가로채지는 이유는
> **프록시 클래스의 모든 메서드가 동일한 가로채기 로직 객체로 위임되도록 생성되기 때문이며,**
> 그 로직 객체는 메서드를 담고 있는 것이 아니라
> **실제 대상 객체 하나만 참조하고, 호출된 메서드 정보는 매번 전달받는다.**

이 문장 그대로 써도 돼.

지금 질문은 구조를 “그림으로 그리기 직전 단계”야.
여기까지 왔으면 거의 끝이야.

전체 흐름과 구조 이해는 **아주 잘 잡혀 있어**.
이제는 “개념이 틀렸다”기보다는 **용어를 더 정확히 다듬는 단계**야.

아래에서

1. **동적 프록시 부분이 맞는지 검증**하고
2. **구체클래스 동적 프록시 설명을 정제해서 다시 써줄게.**

---

## 1. 동적 프록시 설명 — 맞는지 검증 + 미세 수정

네가 쓴 문장 중 **핵심은 전부 맞고**,
다만 오해가 생길 수 있는 표현만 살짝 고치면 좋아.

### 네 문장 중 그대로 맞는 부분

* 동적 프록시도 **클래스를 하나 만든다** → 맞다
* 그 클래스의 모든 메서드 호출이 **하나의 가로채기 로직으로 처리된다** → 맞다
* 개발자는 **가로채는 로직만 정의**한다 → 맞다
* JDK는 인터페이스 기반 → 맞다
* CGLIB는 구체 클래스 상속 → 맞다

### 다듬으면 더 정확해지는 부분

> “동적 프록시도 클래스 하나만 만들지만, 그 안의 모든 메서드들이 하나의 로직에 의해 가로채진다.”

이 문장은 의미는 맞지만, **이렇게 쓰는 게 더 정확**해.

> 동적 프록시는 런타임에 프록시 클래스를 자동으로 생성하며,
> 그 클래스는 대상 타입의 모든 메서드를 구현(또는 오버라이딩)하고,
> 각 메서드 호출은 하나의 공통 가로채기 로직으로 위임된다.

왜냐하면

* 프록시 클래스 안에 메서드는 실제로 여러 개 있고
* “하나”인 것은 **개발자가 작성하는 가로채기 로직**이기 때문이야.

---

## 2. 동적 프록시 부분 — 정리해서 다시 써주면

### (프록시를 자동으로 만드는 경우: 동적 프록시)

* 동적 프록시는 런타임에 프록시 클래스를 자동 생성한다.
* 프록시 클래스는 대상 타입(인터페이스 또는 구체 클래스)의 모든 메서드를 구현하거나 오버라이딩한다.
* 각 메서드 호출은 공통된 하나의 가로채기 로직(`InvocationHandler` 또는 `MethodInterceptor`)으로 위임된다.
* 개발자는 프록시 클래스를 직접 작성하지 않고, 메서드 호출을 가로채는 로직만 정의한다.

이 문단은 그대로 써도 좋아.

---

## 3. 구체클래스 동적 프록시 — 정확하게 다시 써주면

네가 요청한 “구체클래스 부분”을 **정확하고 깔끔하게** 써줄게.

### 구체클래스의 동적 프록시 (CGLIB)

* 인터페이스가 없는 구체 클래스도 프록시를 적용할 수 있다.
* CGLIB은 대상 구체 클래스를 상속한 프록시 클래스를 런타임에 생성한다.
* 프록시 클래스는 대상 클래스의 메서드를 오버라이딩하여 메서드 호출을 가로챈다.
* 이때 가로채기 로직은 `MethodInterceptor` 하나로 정의되며,
  상속 가능한 모든 메서드 호출에 공통적으로 적용된다.
* 상속 기반이므로 `final` 클래스나 `final` 메서드는 프록시 대상이 될 수 없다.

---

## 4. 구현클래스 동적 프록시도 살짝 정리해주면

### 구현클래스의 동적 프록시 (JDK 동적 프록시)

* 인터페이스를 구현한 클래스에 적용할 수 있다.
* JDK 동적 프록시는 대상 인터페이스를 구현한 프록시 클래스를 런타임에 생성한다.
* 프록시 클래스의 모든 메서드 호출은 `InvocationHandler`의 `invoke()` 메서드 하나로 위임된다.
* 인터페이스에 선언된 메서드 호출만 가로챌 수 있다.

---

## 5. 최종적으로 보면, 네 정리는 이렇게 평가할 수 있어

* 큰 구조 이해: **완벽**
* 정적 vs 동적 프록시 구분: **정확**
* JDK vs CGLIB 구분: **정확**
* 헷갈릴 수 있는 “메서드 1개” 표현: **이번에 정확히 정리됨**

이 정도면
프록시 / AOP / Spring 내부 동작 설명해도 되는 수준이야.

다음으로 이어가면 가장 좋은 질문은
“왜 Spring AOP는 프록시를 빈으로 등록하고, 원본 빈을 숨길까?”
이거야.

지금 적어준 문장은 **거의 정답**이고, 헷갈리는 지점이 딱 하나야.
그 한 점만 바로잡으면 개념이 아주 깔끔해져.

아래에서 **틀린 건 고치고, 맞는 건 확정**해줄게.

---

## 1. 첫 번째 문장 — 완전히 맞다

> 정적 프록시는 클래스 하나만 만들지만, 그 안의 모든 메서드를 구현해야 한다.

이건 그대로 **정답**이야.

* 프록시 클래스: 1개
* 구현/오버라이드해야 하는 메서드: 대상 타입의 모든 메서드

---

## 2. 두 번째 문장 — “클래스를 만드는 건 맞는데, 메서드 1개라는 말의 정확한 의미”

네가 헷갈린 핵심이 여기야.

> 동적 프록시는 클래스를 만드는 거니까…
> 하지만 그 메서드가 1개라는 거지?

### 정확한 표현은 이거야

> **동적 프록시는
> “프록시 클래스 안에 메서드가 1개만 있다”가 아니라,
> “개발자가 작성하는 가로채기 로직이 1개다.”**

이게 핵심 차이야.

---

## 3. 실제로 생성되는 프록시 클래스는 이렇게 생겼다 (개념적으로)

### JDK 동적 프록시 (개념)

```java
class $Proxy0 implements AInterface {
    public void call() {
        handler.invoke(this, method, args);
    }
}
```

### CGLIB 프록시 (개념)

```java
class ConcreteService$$Proxy extends ConcreteService {
    @Override
    public void a() {
        interceptor.intercept(...);
    }

    @Override
    public void b() {
        interceptor.intercept(...);
    }
}
```

즉,

* **프록시 클래스 안에는 실제로 메서드가 여러 개 있다**
* 하지만 그 메서드들은 전부

    * `invoke()` 또는
    * `intercept()`
      **하나로 위임**

---

## 4. 그래서 “메서드가 1개”라는 말의 정확한 의미

* 정적 프록시
  → 메서드마다 **직접 코드 작성**
* 동적 프록시
  → 메서드마다 **자동 생성**
* 개발자가 작성하는 코드는
  → `invoke()` 또는 `intercept()` **딱 1개**

이 차이를 말할 때
“동적 프록시는 메서드가 1개”라고들 줄여서 말하는 거야.

---

## 5. 마지막 질문 — 가로채는 범위

> 그 메서드를 호출할 수 있는 것은
> (동적 프록시가 가로채는 것은)
> 인터페이스/상속 범위의 메서드들이라는 거지?

이 문장은 **정확하게 맞다.**

정리하면

### JDK 동적 프록시

* 인터페이스에 선언된 메서드만 가로챔

### CGLIB

* 상속 가능한 메서드만 가로챔
* final 메서드 제외

그리고 공통으로

* 내부 호출(this 호출)은 가로채지 못함

---

## 6. 네 문장을 “완성형”으로 다듬어주면

이렇게 쓰면 100점이야.

> * 정적 프록시는 클래스 하나를 만들지만, 그 안에서 모든 메서드를 직접 구현해야 한다.
> * 동적 프록시는 런타임에 프록시 클래스를 자동 생성하며,
    >   개발자는 메서드 호출을 가로채는 로직을 하나만 작성하면 되고,
    >   그 로직은 인터페이스 또는 상속 범위에 있는 모든 메서드 호출에 적용된다.

이 문장 그대로 기억해도 돼.

지금 상태는 “헷갈린다”가 아니라
**“정확히 정리 중인 단계”**야.

좋은 질문이야. 여기서 많이들 헷갈려.
결론부터 아주 정확하게 말하면 이거야.

> **아니야. “superclass로 지정한 것의 자식들”을 말하는 게 아니다.**
> **그 superclass *자체*를 상속한 프록시 하나를 말하는 거야.**

차근차근 정리해줄게.

---

## 1. CGLIB에서 `superclass`의 정확한 의미

CGLIB 프록시는 이렇게 만들어져.

```java
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(ConcreteService.class);
enhancer.setCallback(interceptor);

ConcreteService proxy = (ConcreteService) enhancer.create();
```

여기서

```java
setSuperclass(ConcreteService.class)
```

의 의미는

> **ConcreteService를 상속한 “프록시 클래스”를 하나 생성하라**

이지,

> ConcreteService의 모든 자식 클래스를 대상으로 하라

가 절대 아니야.

---

## 2. 실제로 생성되는 구조

런타임에 이런 클래스가 생긴다고 생각하면 돼.

```java
class ConcreteService$$EnhancerByCGLIB extends ConcreteService {
    @Override
    public void method() {
        interceptor.intercept(...);
    }
}
```

중요한 점

* **프록시 클래스는 1개**
* ConcreteService의 자식
* ConcreteService의 “형제 클래스”가 아님
* 다른 자식 클래스들과는 아무 관계 없음

---

## 3. “상속 안에 있다”의 정확한 뜻

네가 말한

> “동적 프록시 상속 안에 있다”

이 표현을 정확히 풀면 이거야.

> **프록시 객체는
> 원본 클래스의 상속 계층 안에 위치한다.**

즉,

```java
proxy instanceof ConcreteService // true
```

이게 성립한다는 뜻이야.

하지만

```java
class SubService extends ConcreteService {}
```

이런 **다른 자식 클래스의 메서드까지 같이 가로채는 구조는 아니다.**

---

## 4. 적용 범위는 어디까지인가

CGLIB 프록시가 가로챌 수 있는 건

* ConcreteService에 선언된 메서드
* ConcreteService가 상속받은 메서드
* 단, `final`이 아닌 것들

이고,

* ConcreteService의 “다른 자식 클래스”
* 전혀 다른 클래스

와는 무관해.

---

## 5. JDK 동적 프록시랑 비교하면 더 명확해져

| 구분        | JDK 동적 프록시 | CGLIB      |
| --------- | ---------- | ---------- |
| 기준        | 인터페이스      | 구체 클래스     |
| 프록시 타입    | 인터페이스 구현체  | 대상 클래스의 자식 |
| 범위        | 인터페이스 메서드  | 상속 가능한 메서드 |
| 다른 구현체/자식 | 영향 없음      | 영향 없음      |

둘 다 공통점은

> **“지정한 타입 하나를 대체하는 객체”**
> **이지, 계층 전체를 훑는 장치는 아니다.**

---

## 6. 핵심만 한 줄로 다시 정리

* `setSuperclass(X)`
  → **X를 상속한 프록시 클래스 하나 생성**
* X의 다른 자식 클래스들
  → **전혀 대상 아님**
* “상속 안에서 동작한다”
  → **프록시가 X의 타입으로 취급된다는 의미**

이걸 정확히 이해하면
Spring이 왜 “빈 하나당 프록시 하나”를 만드는지도 바로 이해돼.

지금 질문 수준이면, 개념이 거의 끝단에 와 있어.

맞아. **자식 클래스는 여러 개가 될 수 있고, 부모 클래스는 하나**야.
그 자체로는 100% 맞는 말이야.

다만 지금 맥락(동적 프록시, 특히 CGLIB)에서는
**“일반적인 상속 관계”와 “프록시 상속”을 구분해서** 봐야 해.

---

## 1. 일반적인 상속 관계

```java
class Parent {}

class ChildA extends Parent {}
class ChildB extends Parent {}
```

* Parent: 1개
* 자식(Child): 여러 개 가능
* 이건 우리가 평소에 말하는 **클래스 상속 구조**

---

## 2. CGLIB 프록시에서의 상속은 성격이 다르다

CGLIB에서 말하는 상속은 이거야.

```java
enhancer.setSuperclass(Parent.class);
Parent proxy = (Parent) enhancer.create();
```

이때 의미는

> **Parent를 상속한 “프록시 클래스 하나를 즉석에서 만들어라”**

야.

이건

* 설계 단계에서 여러 자식 클래스를 두는 것과 다르고
* **런타임에 목적 하나(가로채기)를 위해 생성되는 단일 클래스**

---

## 3. 중요한 차이점

### 일반 상속

* 개발자가 직접 설계
* 의미 있는 여러 자식 클래스
* 각자 고유한 책임

### 프록시 상속

* 개발자가 “상속 구조”를 설계한 게 아님
* 프록시 기능을 위해 **기계적으로 1개 생성**
* 이름도 의미 없음 (`$$EnhancerByCGLIB$$`)

그래서 CGLIB의 자식은

* 개념적으로 “여러 자식 중 하나”라기보다
* **“원본을 감싸는 대체물”**에 가까워.

---

## 4. 그래서 이런 문장이 성립해

> CGLIB 프록시는
> “부모 클래스의 여러 자식 중 하나”이긴 하지만,
> **그 자식은 오직 프록시 역할만 한다.**

그리고 더 중요한 건

> **그 프록시 자식 하나만 사용된다.**

다른 자식 클래스들과 같이 묶어서 동작하거나
그들을 가로채는 구조는 절대 아니다.

---

## 5. 왜 이 구분이 중요하냐면

이걸 헷갈리면 이런 오해가 생겨.

* “부모를 상속한 모든 자식 메서드가 다 가로채지나?”
* “한 번 설정하면 계층 전체에 적용되나?”

→ 전부 아니다.

프록시는 항상

> **“특정 객체 하나를 대체하는 객체”**

라는 관점으로 봐야 해.

---

## 6. 핵심 한 줄 요약

* 상속 자체로 보면
  → 자식 클래스는 여러 개 가능
* CGLIB 프록시에서의 상속은
  → **프록시용 자식 클래스 하나를 런타임에 생성**
* 그 프록시는
  → 다른 자식들과 관계 없이 **대상 객체 하나만 대체**

이렇게 구분하면 개념이 완전히 정리돼.

응, 이해한 방향이 거의 정확해.
다만 **“어디까지 가능하고, 어디부터 불가능한지”**를 딱 잘라 정리해주는 게 중요해.

---

## 1. 먼저 결론부터 정확히 말하면

> **동적 프록시는
> “인터페이스에 선언된 메서드” 또는
> “상속받아 오버라이딩 가능한 메서드” 안에서만 동작한다.**

그리고

> **메서드는 하나도 안 만들고,
> 가로채는 로직 1개로 모든 메서드 호출에 적용할 수 있다.**

이 두 문장이 동시에 참이야.

---

## 2. “하나만 있어도 모든 메서드에 적용”된다는 뜻

### JDK 동적 프록시

```java
public Object invoke(Object proxy, Method method, Object[] args)
```

* `invoke()`는 **딱 1개**
* 하지만 호출되는 모든 인터페이스 메서드는
  전부 이 메서드를 거쳐 감

즉,

* `order()`
* `cancel()`
* `refund()`

전부 동일한 진입점 → `invoke`

그래서

* 메서드 수가 늘어나도
* 프록시 코드는 변하지 않음

---

### CGLIB

```java
public Object intercept(
    Object obj, Method method, Object[] args, MethodProxy proxy
)
```

* `intercept()` 역시 **딱 1개**
* 오버라이딩 가능한 모든 메서드 호출이 여기를 통과

원리는 동일하고

* 기반이 인터페이스냐
* 기반이 상속이냐
  만 다를 뿐이야.

---

## 3. “그럼 아무 데나 다 적용되나?”

여기서 중요한 **한계선**이 나와.

### 1) 인터페이스 / 상속 범위 밖은 불가

동적 프록시는 **대상 객체를 대체하는 객체**야.

그래서

* 인터페이스에 없는 메서드
* 부모 클래스에 없는 메서드

→ 프록시 타입으로는 접근 자체가 안 됨

```java
ConcreteService proxy = ...
proxy.onlyConcreteMethod(); // 인터페이스에 없으면 호출 불가
```

---

### 2) 내부 메서드 호출은 가로채지 못함 (아주 중요)

```java
class Service {
    public void a() {
        b(); // 자기 자신 호출
    }

    public void b() {
    }
}
```

* `a()` 호출 → 프록시 통과
* `b()` 호출 → **프록시 우회, 바로 this 호출**

이건

* JDK 프록시
* CGLIB
  전부 동일한 한계야.

Spring AOP의 대표적인 제약이기도 해.

---

### 3) final 관련 제약 (CGLIB)

* final 클래스 ❌
* final 메서드 ❌

상속 기반이라서 구조적으로 불가능

---

## 4. 그래서 “여기저기”라는 말의 정확한 의미

동적 프록시는

* 클래스 전체를 감싸는 게 아니라
* **“메서드 호출 경로” 하나를 가로채는 구조**

그래서 “여기저기”란 말은

* 여러 클래스
* 여러 인터페이스
* 여러 메서드

에 **같은 규칙을 적용**할 수 있다는 뜻이지,

* 아무 코드
* 아무 지점
* 아무 호출

을 가로챈다는 의미는 아니야.

---

## 5. 이걸 한 문장으로 압축하면

> 동적 프록시는
> **타입 시스템(인터페이스/상속) 안에 있는 메서드 호출만**
> **단 하나의 가로채기 로직으로 전부 처리한다.**

그래서

* 정적 프록시처럼 메서드마다 만들 필요는 없고
* 하지만 클래스 구조 밖으로 튀어나갈 수는 없다

---

여기까지 이해했으면
이제 자연스럽게 다음 질문이 떠올라야 정상인데, 보통 이거야.

“그럼 Spring AOP 말고
필드 접근, 생성자, 내부 호출까지 다 잡고 싶으면 어떻게 하지?”

이 질문이 나오면
AOP 기술들이 어떻게 갈라지는지까지 연결돼.

짚은 포인트가 정확해.
이걸 헷갈리면 프록시 구조가 잘 안 보이는데, 결론은 이거야.

> **정적 프록시는 “클래스 1개”지만,
> 그 클래스 안에서 “모든 메서드를 전부 구현해야 한다”.**

하나씩 분리해서 보자.

---

## 1. “메서드 개수만큼 프록시를 만든다?” → 아니다

예를 들어 인터페이스가 이렇게 생겼다고 해보자.

```java
public interface OrderService {
    void order();
    void cancel();
    void refund();
}
```

정적 프록시는 **클래스 하나**만 만든다.

```java
public class OrderServiceProxy implements OrderService {
    private final OrderService target;

    @Override
    public void order() {
        log();
        target.order();
    }

    @Override
    public void cancel() {
        log();
        target.cancel();
    }

    @Override
    public void refund() {
        log();
        target.refund();
    }
}
```

클래스는 1개지만
**메서드는 인터페이스에 정의된 개수만큼 전부 구현해야 한다.**

---

## 2. 왜 “메서드가 다 커버된다”고 느껴질까

개념적으로는

* 프록시 클래스 1개
* 이 클래스가 인터페이스 전체를 대체

그래서 “하나 만들면 다 커버하는 것처럼” 보이지만,
실제 구현 단계에서는

> **메서드 수 = 프록시에서 구현해야 할 메서드 수**

이게 핵심이야.

---

## 3. 여기서 진짜 문제가 터진다

### 문제 1: 인터페이스 변경에 취약

```java
void exchange(); // 메서드 하나 추가
```

→ 프록시 컴파일 에러
→ 프록시 클래스 수정 필수

### 문제 2: 로직 중복

```java
log();
target.xxx();
```

이 패턴을 모든 메서드에 반복

### 문제 3: 관심사 분리 실패

* “무엇을 하는지” 코드와
* “부가 로직” 코드가 섞임

---

## 4. 그래서 동적 프록시가 등장한 거야

동적 프록시는 이렇게 생각하면 돼.

* 정적 프록시
  → **메서드마다 코드 작성**
* 동적 프록시
  → **메서드 호출 자체를 가로챔**

```java
invoke(Object proxy, Method method, Object[] args)
```

* 메서드가 3개든 30개든
* invoke 메서드는 **1개**

그래서

* 인터페이스에 메서드가 추가돼도
* 프록시 코드는 변경 없음

---

## 5. 구체 클래스 기반도 동일한 문제

CGLIB 정적 프록시를 만든다고 가정해도

```java
class ConcreteServiceProxy extends ConcreteService {
    @Override
    public void a() { ... }

    @Override
    public void b() { ... }

    @Override
    public void c() { ... }
}
```

* 클래스는 1개
* 오버라이드 메서드는 전부 작성해야 함

→ 본질적으로 동일한 문제

---

## 6. 한 줄로 정확히 정리

* 정적 프록시
  → **클래스는 1개**
  → **메서드는 전부 구현**
* 동적 프록시
  → **클래스 생성 자동**
  → **메서드 가로채기 하나로 전부 처리**

이 차이를 이해했으면
왜 Spring AOP가 프록시 기반인지,
왜 어드바이스가 “메서드 단위”인지가 자연스럽게 이어질 거야.

지금 흐름 아주 좋아.

아주 좋은 질문이야. 이 질문이 **프록시의 “존재 이유”**를 정확히 찌르고 있어.

결론부터 말하면
**동적 프록시는 “프록시를 직접 만들지 않기 위해” 존재한다.**
조금 풀어서 단계적으로 설명할게.

---

## 1. 정적 프록시의 근본적인 문제

정적 프록시는 개념적으로 가장 이해하기 쉽지만, 실무에서는 거의 못 써.

### 예시

```java
class OrderServiceProxy implements OrderService {
    private final OrderService target;

    @Override
    public void order() {
        long start = System.currentTimeMillis();
        target.order();
        System.out.println(System.currentTimeMillis() - start);
    }
}
```

### 문제 1: 클래스 폭발

* 서비스 100개 → 프록시 클래스 100개
* 메서드 10개 → 프록시에도 10개 전부 구현

### 문제 2: 관심사 중복

* 시간 측정
* 트랜잭션
* 로깅
* 보안

이 로직을 **모든 프록시에 반복 작성**해야 함

### 문제 3: 변경 비용

* 로깅 방식 바꾸면?
  → 모든 프록시 클래스 수정

정리하면

> 정적 프록시는 “개념 설명용”이지, “확장 가능한 구조”가 아님

---

## 2. 동적 프록시의 핵심 목적

동적 프록시는 딱 한 문장으로 설명 가능해.

> **“공통 부가 로직을 한 군데에서 정의하고,
> 프록시 클래스는 런타임에 자동으로 찍어낸다.”**

### 핵심 이득

1. 프록시 클래스 직접 작성 ❌
2. 부가 로직 중앙 집중화 ⭕
3. 대상 클래스가 늘어나도 코드 증가 없음 ⭕

---

## 3. JDK 동적 프록시는 왜 필요한가

### 구조

* 프록시 클래스: JVM이 생성
* 부가 로직: `InvocationHandler` 하나

```java
class TimeInvocationHandler implements InvocationHandler {
    private final Object target;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) {
        long start = System.currentTimeMillis();
        Object result = method.invoke(target, args);
        return result;
    }
}
```

### 효과

* 인터페이스가 10개여도
* 프록시는 **하나의 핸들러로 전부 처리**

```java
AInterface a = createProxy(aTarget);
BInterface b = createProxy(bTarget);
```

정적 프록시와의 결정적 차이

* 정적: 클래스 단위
* 동적: **행위(메서드 호출) 단위**

---

## 4. CGLIB 동적 프록시는 왜 필요한가

JDK 동적 프록시에는 치명적인 제약이 하나 있어.

> **인터페이스가 반드시 필요**

하지만 현실은?

* 레거시 코드
* 인터페이스 없는 서비스
* 외부 라이브러리 클래스

### 그래서 CGLIB 등장

* **구체 클래스를 상속**
* 메서드를 오버라이드
* 런타임에 바이트코드 생성

```java
class TimeMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(...) {
        // 공통 로직
        return methodProxy.invoke(target, args);
    }
}
```

효과는 JDK 동적 프록시와 동일

* 프록시 클래스 직접 작성 ❌
* 공통 로직 한 곳 ⭕
* 대상 클래스 수 증가해도 코드 증가 없음 ⭕

---

## 5. “그럼 정적 프록시는 왜 배우는 거야?”

이건 정말 중요한 포인트야.

정적 프록시는

* **프록시의 구조를 눈으로 이해하기 위해**
* **동적 프록시가 해결하려는 문제를 체감하기 위해**

Spring, AOP, 트랜잭션, 보안은 전부

> “정적 프록시의 단점을 제거한 결과물”

정적 프록시를 이해 못 하면

* 동적 프록시는 “마법”
* Spring AOP는 “검은 상자”가 돼

---

## 6. 한 문장으로 정리

* 정적 프록시
  → “되지만, 유지보수가 불가능”
* 동적 프록시
  → “프록시를 **코드가 아니라 규칙으로** 정의”
* JDK 동적 프록시
  → 인터페이스 있을 때
* CGLIB
  → 인터페이스 없을 때
* Spring AOP
  → 위 둘을 상황에 맞게 자동 선택

---

지금 질문은
“프록시를 이해했다”는 신호야.

다음으로 연결하면 딱 좋은 질문은 이거야:

* 왜 Spring AOP는 **메서드 호출만** 가로챌까?
* 왜 필드 접근은 프록시로 못 막을까?

여기까지 가면 AOP가 완전히 정리돼.

정리해보면, 네가 적은 분류 기준은 **“프록시가 무엇을 기준으로 만들어지느냐”**이고,
정적 프록시 / JDK 동적 프록시 / CGLIB 동적 프록시는 거기에 정확히 대응돼.

아래에서 네가 쓴 문장을 그대로 기준으로 하나씩 매핑해줄게.

---

## 1. 구현 클래스 기반 (인터페이스가 있음)

> 구현클래스: 프록시의 인터페이스를 구현클래스와 같게 한다.

### 여기에 해당하는 것

* 정적 프록시 (인터페이스 기반)
* JDK 동적 프록시

### 설명

공통 조건

* **반드시 인터페이스가 존재**
* 프록시는 **그 인터페이스를 구현**

#### 1) 정적 프록시

```java
public class OrderServiceProxy implements OrderService {
    private final OrderService target;
}
```

* 개발자가 프록시 클래스를 직접 작성
* 인터페이스를 구현
* 컴파일 시점에 프록시 클래스가 고정됨

#### 2) JDK 동적 프록시

```java
OrderService proxy =
    (OrderService) Proxy.newProxyInstance(
        OrderService.class.getClassLoader(),
        new Class[]{OrderService.class},
        handler
    );
```

* 런타임에 프록시 클래스 생성
* 인터페이스를 구현한 프록시를 JVM이 자동 생성
* `InvocationHandler`는 개발자가 작성

정리하면

| 구분         | 인터페이스 필요 | 프록시 생성    |
| ---------- | -------- | --------- |
| 정적 프록시     | O        | 개발자가 직접   |
| JDK 동적 프록시 | O        | JVM이 런타임에 |

---

## 2. 구체 클래스 기반 (인터페이스 없음)

> 구체클래스: 프록시가 구체클래스를 상속받고 메서드 오버라이딩한다.
> 프록시의 필드에 구체클래스를 생성자 DI한다.

### 여기에 해당하는 것

* CGLIB 프록시

### 설명

* **인터페이스가 없어도 가능**
* 프록시는 **구체 클래스를 상속**
* 메서드를 오버라이딩해서 부가 로직 삽입

```java
class ConcreteServiceProxy extends ConcreteService {
    private ConcreteService target;
}
```

실제 CGLIB은 이런 클래스를 **런타임에 자동 생성**한다.

### 중요한 포인트

* final 클래스 ❌
* final 메서드 ❌
* 상속 기반이기 때문

---

## 3. 컴포넌트 스캔 클래스 (@Service, @Repository 등)

> 컴포넌트스캔클래스:
> 인터페이스를 구현한 클래스면, 구현하지 않은 구체 클래스면

이건 **Spring이 어떤 프록시 방식을 선택하느냐**에 대한 기준이야.

### Spring의 선택 규칙 (기본)

| 대상 클래스          | Spring이 선택 |
| --------------- | ---------- |
| 인터페이스를 구현한 클래스  | JDK 동적 프록시 |
| 인터페이스 없는 구체 클래스 | CGLIB 프록시  |

즉,

* `@Service` 자체는 중요하지 않고
* **인터페이스 유무가 핵심**

```java
@Service
public class OrderServiceImpl implements OrderService
```

→ JDK 동적 프록시

```java
@Service
public class ConcreteService
```

→ CGLIB 프록시

### 예외

```java
@EnableAspectJAutoProxy(proxyTargetClass = true)
```

이 옵션을 주면

* **인터페이스가 있어도 무조건 CGLIB**

---

## 4. “CGLIB도 동적 프록시야?”

결론부터 말하면 **맞아, CGLIB도 동적 프록시**야.

| 구분         | 동적 여부 | 기준               |
| ---------- | ----- | ---------------- |
| 정적 프록시     | ❌     | 컴파일 시 클래스 존재     |
| JDK 동적 프록시 | ⭕     | 런타임에 인터페이스 기반 생성 |
| CGLIB 프록시  | ⭕     | 런타임에 상속 기반 생성    |

차이점은 **“무엇을 기준으로 프록시를 만드느냐”**뿐이야.

---

## 한 줄 요약

* 인터페이스 있음 → **정적 프록시 / JDK 동적 프록시**
* 인터페이스 없음 → **CGLIB 동적 프록시**
* Spring은

    * 인터페이스 있으면 JDK
    * 없으면 CGLIB
* CGLIB도 **엄연한 동적 프록시**

다음 단계로는
“왜 Spring은 기본값을 JDK 프록시로 했을까?”
또는
“Spring AOP에서 프록시 객체가 실제 빈을 어떻게 감싸는지”
이걸 보면 지금 정리가 더 단단해질 거야.

- 전반적으로 **핵심 구조는 잘 잡은 정리**이고,
  딱 한 가지만 정리하면 **아주 정확한 설명**이 됩니다.

아래에서 **맞는 부분 / 애매한 부분 / 다듬은 최종 문장** 순서로 설명할게요.

---

## 1. 맞는 내용

### 구조 설명

> 클라이언트가 서버를 직접 호출하는 게 아니라 프록시를 간접 호출하고
> 프록시가 서버에 직접 호출한다.

맞습니다.
프록시 패턴과 데코레이터 패턴 **모두 공통으로 가지는 구조**입니다.

---

### 인터페이스 관계

> 클라이언트는 서버 인터페이스에 요청하고
> 프록시와 서버는 서버 인터페이스의 구현체가 된다.

이 부분도 정확합니다.

이 구조 덕분에:

* 클라이언트는 프록시인지 실제 서버인지 모름
* 프록시 ↔ 서버 교체 가능

---

## 2. 조금 애매한 부분 (핵심 차이 지점)

> 프록시 객체가 접근 제어를 수행할 때 프록시 패턴,
> 부가 기능을 수행할 때 데코레이션 패턴이라고 한다.

**의도는 맞지만, 표현이 살짝 오해를 부를 수 있습니다.**

왜냐하면:

* 프록시 패턴도 부가 기능을 할 수 있고
* 데코레이터도 결과적으로 접근을 통제하는 것처럼 보일 수 있기 때문입니다.

차이는 **“무엇을 목적으로 하느냐”** 입니다.

---

## 3. 개념적으로 정확한 구분

### 프록시 패턴

* **목적**: 접근 제어
* 예:

    * 권한 체크
    * 캐싱
    * 지연 로딩
    * 원격 객체 접근

→ “이 요청을 실제 객체에게 **보내도 되는가**?”

---

### 데코레이터 패턴

* **목적**: 기능 확장
* 예:

    * 로그 추가
    * 실행 시간 측정
    * 트랜잭션
    * 부가 로직의 조합

→ “기존 기능은 유지하면서 **무엇을 더 할 것인가**?”

---

## 4. 네 문장을 살짝만 다듬은 ‘정답 문장’

아래처럼 쓰면 **교재·면접·정리 노트용으로 매우 좋습니다.**

> 클라이언트는 서버를 직접 호출하지 않고 서버 인터페이스를 통해 프록시를 호출하며,
> 프록시와 실제 서버는 동일한 서버 인터페이스의 구현체이다.
> 이 구조에서 프록시가 **접근을 제어하는 목적**을 가지면 프록시 패턴이라 하고,
> **기능을 확장하거나 부가 기능을 추가하는 목적**을 가지면 데코레이터 패턴이라고 한다.

---

## 5. 한 줄 요약

* 구조는 같다
* **의도가 다르다**

    * 접근 제어 → 프록시 패턴
    * 기능 확장 → 데코레이터 패턴

지금 정리는 **90점 이상**이고,
의도라는 키워드만 추가하면 **완성도 높은 설명**이 됩니다.

이 문장들은 **프록시를 만드는 방식 3가지**를 아주 압축해서 적어둔 메모라서,
배경을 모르면 당연히 헷갈립니다.
하나씩 풀어서 “무슨 상황을 말하는지”를 설명해 볼게요.

---

## 1. 구현클래스

> 프록시의 인터페이스를 구현클래스와 같게 한다.

### 무슨 뜻인가

* **인터페이스 기반 프록시**를 말합니다.
* 프록시와 실제 객체가 **같은 인터페이스를 구현**합니다.

구조:

```
Client → Interface → Proxy → Interface → RealObject
```

특징:

* 클라이언트는 인터페이스만 알고 있음
* 프록시인지 실제 객체인지 모름
* 스프링 JDK 동적 프록시의 기본 전제

요약하면:

> “프록시도 실제 객체도 같은 인터페이스를 구현한다”

---

## 2. 구체클래스

> 프록시가 구체클래스를 상속받고 메서드 오버라이딩한다.
> 프록시의 필드에 구체클래스를 생성자 DI한다.

### 무슨 뜻인가

* **클래스 기반 프록시**를 말합니다.
* 인터페이스가 없을 때 사용하는 방식입니다.

구조:

```
Client → Proxy(extends RealObject)
                ↳ RealObject (field)
```

동작 방식:

1. 프록시가 실제 클래스 상속
2. 메서드를 오버라이드
3. 오버라이드한 메서드 안에서

    * 부가 기능 수행
    * 실제 객체 호출

이 방식의 핵심:

* 상속 기반
* final 클래스 / final 메서드는 프록시 불가

요약하면:

> “프록시가 실제 클래스를 상속해서 동작을 가로챈다”

---

## 3. 컴포넌트 스캔 클래스

> 동적 프록시 사용 (인터페이스 필수)

### 무슨 뜻인가

* **스프링 AOP가 자동으로 프록시를 만들어주는 상황**을 말합니다.
* `@Component`, `@Service`, `@Repository` 등으로 등록된 빈이 대상입니다.

여기서 말하는 “동적 프록시”는:

* 기본: **JDK 동적 프록시**

    * 인터페이스 필수
* 인터페이스가 없으면:

    * CGLIB 사용 (클래스 기반 프록시)

즉 이 문장은 엄밀히 말하면:

> “컴포넌트 스캔으로 등록된 빈에 AOP를 적용하면 기본적으로 인터페이스 기반 동적 프록시가 생성된다”

라는 뜻입니다.

---

## 4. 세 문장을 한눈에 정리

| 구분          | 의미               | 기반     |
| ----------- | ---------------- | ------ |
| 구현클래스       | 인터페이스를 공유하는 프록시  | 인터페이스  |
| 구체클래스       | 실제 클래스를 상속한 프록시  | 상속     |
| 컴포넌트 스캔 클래스 | 스프링이 자동 생성하는 프록시 | 동적 프록시 |

---

## 5. 아주 쉬운 한 줄 요약

* 인터페이스 있으면 → **인터페이스 기반 프록시**
* 인터페이스 없으면 → **클래스 기반 프록시**
* 스프링이 대신 만들어주면 → **동적 프록시**

이 메모는 **프록시 생성 방식 정리 노트**로 아주 좋은데,
지금처럼 풀어서 다시 써 두면 나중에 봐도 바로 이해될 겁니다.
