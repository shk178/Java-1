# 7. 컬렉션 프레임워크 - 해시
- (1) Set
- 유일한 요소들의 컬렉션
- 중복x, 입/출력 순서 미보장, 요소 유무 확인에 최적화
- 요소 유무 확인의 최적화 = 빠른 유무 검색
- List: 장바구니 목록, 순서가 중요한 이벤트 목록
- Set: 회원ID 집합, 고유 항목 집합
- (2) Set 직접 구현
- 251007-java-mid2/src/hash/hashSet.java
- contains가 add를 O(n)으로 만든다.
- 해시 알고리즘: 중복 확인을 빠르게 만든다.
- 데이터 값 자체를 배열의 인덱스로 사용한다면..
- 검색이 빨라질 것이다. 하지만 메모리 낭비된다.
- 나머지 연산을 활용하면 메모리 절약된다.
- (3) 나머지 연산
- hashIndex(): 해시 인덱스를 반환
- 해시 인덱스는 입력 값을 계산해서 인덱스로 사용하는 것을 말한다.
- 여기서는 입력 값을 배열의 크기로 나머지 연산해서 구한다.
- add(): true(추가함)/false(추가 안 함)를 반환
- 해시 인덱스를 먼저 구한다.
- 구한 해시 인덱스의 위치에 데이터를 저장한다.
- 조회: 해시 인덱스를 구하고, `배열명[해시 인덱스]`로 값을 조회한다.
- 해시가 충돌할 수 있는 한계가 있다.
- (4) 해시 충돌 해결
- CAPACITY를 늘리는 것: 메모리 낭비, 복잡한 구현 등 문제
- 배열 안에 배열 등 만드는 것: 한 인덱스에만 계속 저장되면 문제
- 한 인덱스에 저장되는 (분포가 고르지 않은) 경우는 많지 않다.
- 평균 복잡도는 배열 안에 배열, 리스트 등 만드는 게 낫다.
- 251007-java-mid2/src/hash/hashSet2.java
- 배열이 있고 배열의 요소가 연결 리스트, 연결 리스트의 요소가 Integer인 구조이다.
- list라는 이름보다 buckets(바구니들)라는 이름이 낫다.
- (5) 해시 인덱스 충돌 확률
- 한 인덱스에 데이터가 2개 이상 담길 확률을 말한다.
- 저장할 데이터 수와 배열 크기와 관련이 있다.
- 입력한 데이터 수가 배열 크기 75%를 넘지 않으면 충돌 적다.
- (6) 해시 인덱스 성능
- 데이터 저장: 평균 O(1), 최악 O(n)
- 데이터 조회: 평균 O(1), 최악 O(n)