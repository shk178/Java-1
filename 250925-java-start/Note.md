- 자바 표준 스펙에 따라 회사가 자바 컴파일러, 실행 라이브버리, 가상 머신 만든다.
- javac Hello.java: 소스 파일 컴파일
- Hello.class: 인텔리제이가 디컴파일해서 화면에 띄워줌
- java Hello: .class 바이트코드 실행
- .class 파일은 JVM 위에서 실행되며, JVM만 있으면 어떤 운영체제에서도 실행 가능하다.
- JVM은 각 운영체제에 맞게 구현되어 있어, 바이트코드를 해당 OS 명령어로 변환하여 실행한다.
- 자바는 OS별 명령어를 직접 사용하지 않으며, 이로 인해 OS에 독립적인 실행 환경을 제공한다.
- .class가 달라질 수 있는 경우: javac 옵션이나 JDK 버전이 다를 때
- Windows에서 작성한 자바 코드로 .class 또는 .jar 파일을 만들고, Linux에서 실행 가능
- Windows용 Amazon Corretto로 개발하고, Linux용 Amazon Corretto에서 실행 가능
- 개발과 운영 환경의 JDK 버전만 맞추면 JVM 상호 호환 가능
- .jar 파일 하나로 여러 OS에서 실행 가능 (JVM이 다르더라도)
- Windows에서 빌드한 Maven/Gradle 프로젝트를 .jar로 만들어 서버에 배포 가능
- SCP, FTP, GitHub Actions 등으로 파일 전송 및 자동 배포 가능
- 네이티브 라이브러리(.dll, .so 등)를 사용하는 경우 OS 종속성 문제 발생
- System.getProperty("os.name") 등 OS 의존적인 코드가 있으면 문제 발생
- Windows에서 만든 실행 파일(.exe)은 Linux에서 실행 불가
- .class/.jar 빌드 때 JDK 상위 버전 사용, 서버에 JDK 하위 버전만 설치된 경우 실행 불가
- GUI 기반 Java 앱 (예: Swing) → Headless Linux 서버에서는 실행 불가 (UI 없음)
- 자바 프로그램은 main 메소드부터 실행을 시작한다.
- 지역 변수는 개발자가 초기화, 클래스 변수와 인스턴스 변수는 자동 초기화
- 컴파일 에러: 자바 문법에 맞지 않았을 때 발생하는 에러
- 컴파일 할 때 Var6.java뿐만 아니라 다른 파일도 컴파일하니까 주석 처리한다.
- IntelliJ는 실행할 때, 해당 파일만 컴파일하는 것이 아니라 전체 프로젝트 소스를 컴파일
- 자체 빌드 시스템으로 전체 코드를 분석하고, 의존성 있는 모든 파일을 자동으로 컴파일
- 변경된 파일만 다시 컴파일함 (incremental build)
- Build Output 창에서 어떤 파일이 다시 컴파일되었는지 로그 확인 가능
- Var6.java 디컴파일 해보면 int a;가 최적화로 인해 안 나타난다.
- 정수 리터럴: int 기본, 20억 넘어가면 long
- 실수 리터럴: double 기본
- byte와 short는 표현 길이가 너무 작고, 자바는 4byte(int)를 효율적 계산하도록 설계됨
- byte를 선언하고 숫자 대입해서 계산하기 보다는, 파일을 바이트 단위로 다루고 사용한다.
- float는 표현 길이와 정밀도가 낮다.
- char은 문자 하나를 표현하는 일은 거의 없다. String으로 "a"와 같이 사용해도 된다.
- 규칙: 지키지 않으면 컴파일 오류
- 변수 이름 숫자로 시작 못하는 것이 규칙
- 변수 이름 공백이 없는 것이 규칙
- int, class, public과 같은 자바 예약어를 변수 이름으로 사용할 수 없는 것이 규칙
- 변수 이름 사용 가능: 영문자, 숫자, 달러 기호 또는 밑줄만 인 것이 규칙
- 관례: 변수 이름은 소문자로 시작하고 이후 단어를 대문자로 시작하는 낙타 표기법 사용
- 자바 관례: 클래스 이름의 첫 글자는 대문자로 시작, 나머지는 첫 글자를 소문자로 시작
- 클래스: Person, OrderDetail
- 변수를 포함한 나머지: firstName, userAccount
- 나머지에 예외 2개 있다: 상수는 모두 대문자를 사용하고 언더바로 구분 (USER_LIMIT)
- 예외: 패키지는 모두 소문사를 사용 (org.spring.boot)
- 변수 이름은 의미 있게, 용도를 설명하도록 작성한다.
- Tree Appearance → Compact Middle Packages 코드 영향 없음, 중간 패키지 압축 보기
- 해제 시 장점: 중간 폴더 직접 접근 가능, 파일 추가 편리