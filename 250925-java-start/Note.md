- 자바 표준 스펙에 따라 회사가 자바 컴파일러, 실행 라이브버리, 가상 머신 만든다.
- javac Hello.java: 소스 파일 컴파일
- Hello.class: 인텔리제이가 디컴파일해서 화면에 띄워줌
- java Hello: .class 바이트코드 실행
- .class 파일은 JVM 위에서 실행되며, JVM만 있으면 어떤 운영체제에서도 실행 가능하다.
- JVM은 각 운영체제에 맞게 구현되어 있어, 바이트코드를 해당 OS 명령어로 변환하여 실행한다.
- 자바는 OS별 명령어를 직접 사용하지 않으며, 이로 인해 OS에 독립적인 실행 환경을 제공한다.
- .class가 달라질 수 있는 경우: javac 옵션이나 JDK 버전이 다를 때
- Windows에서 작성한 자바 코드로 .class 또는 .jar 파일을 만들고, Linux에서 실행 가능
- Windows용 Amazon Corretto로 개발하고, Linux용 Amazon Corretto에서 실행 가능
- 개발과 운영 환경의 JDK 버전만 맞추면 JVM 상호 호환 가능
- .jar 파일 하나로 여러 OS에서 실행 가능 (JVM이 다르더라도)
- Windows에서 빌드한 Maven/Gradle 프로젝트를 .jar로 만들어 서버에 배포 가능
- SCP, FTP, GitHub Actions 등으로 파일 전송 및 자동 배포 가능
- 네이티브 라이브러리(.dll, .so 등)를 사용하는 경우 OS 종속성 문제 발생
- System.getProperty("os.name") 등 OS 의존적인 코드가 있으면 문제 발생
- Windows에서 만든 실행 파일(.exe)은 Linux에서 실행 불가
- .class/.jar 빌드 때 JDK 상위 버전 사용, 서버에 JDK 하위 버전만 설치된 경우 실행 불가
- GUI 기반 Java 앱 (예: Swing) → Headless Linux 서버에서는 실행 불가 (UI 없음)
- 자바 프로그램은 main 메소드부터 실행을 시작한다.
- 지역 변수는 개발자가 초기화, 클래스 변수와 인스턴스 변수는 자동 초기화
- 컴파일 에러: 자바 문법에 맞지 않았을 때 발생하는 에러
- 컴파일 할 때 Var6.java뿐만 아니라 다른 파일도 컴파일하니까 주석 처리한다.
- IntelliJ는 실행할 때, 해당 파일만 컴파일하는 것이 아니라 전체 프로젝트 소스를 컴파일
- 자체 빌드 시스템으로 전체 코드를 분석하고, 의존성 있는 모든 파일을 자동으로 컴파일
- 변경된 파일만 다시 컴파일함 (incremental build)
- Build Output 창에서 어떤 파일이 다시 컴파일되었는지 로그 확인 가능
- Var6.java 디컴파일 해보면 int a;가 최적화로 인해 안 나타난다.
- 정수 리터럴: int 기본, 20억 넘어가면 long
- 실수 리터럴: double 기본
- byte와 short는 표현 길이가 너무 작고, 자바는 4byte(int)를 효율적 계산하도록 설계됨
- byte를 선언하고 숫자 대입해서 계산하기 보다는, 파일을 바이트 단위로 다루고 사용한다.
- float는 표현 길이와 정밀도가 낮다.
- char은 문자 하나를 표현하는 일은 거의 없다. String으로 "a"와 같이 사용해도 된다.
- 규칙: 지키지 않으면 컴파일 오류
- 변수 이름 숫자로 시작 못하는 것이 규칙
- 변수 이름 공백이 없는 것이 규칙
- int, class, public과 같은 자바 예약어를 변수 이름으로 사용할 수 없는 것이 규칙
- 변수 이름 사용 가능: 영문자, 숫자, 달러 기호 또는 밑줄만 인 것이 규칙
- 관례: 변수 이름은 소문자로 시작하고 이후 단어를 대문자로 시작하는 낙타 표기법 사용
- 자바 관례: 클래스 이름의 첫 글자는 대문자로 시작, 나머지는 첫 글자를 소문자로 시작
- 클래스: Person, OrderDetail
- 변수를 포함한 나머지: firstName, userAccount
- 나머지에 예외 2개 있다: 상수는 모두 대문자를 사용하고 언더바로 구분 (USER_LIMIT)
- 예외: 패키지는 모두 소문사를 사용 (org.spring.boot)
- 변수 이름은 의미 있게, 용도를 설명하도록 작성한다.
- Tree Appearance → Compact Middle Packages 코드 영향 없음, 중간 패키지 압축 보기
- 해제 시 장점: 중간 폴더 직접 접근 가능, 파일 추가 편리
---
- 0으로 나누면 Exception 오류 발생, 해당 시점 이후의 결과가 출력되지 않고 프로그램이 종료됨
- 연산자 우선순위 1: 괄호 ()
- 연산자 우선순위 2: 단항 연산자 ++, --, !, ~, new, (type)
- 연산자 우선순위 3: 산술 연산자 *, /, %, +, -
- 연산자 우선순위 4: Shift 연산자 <<, >>, >>>
- 연산자 우선순위 5: 비교 연산자 <, <=, >, >=, instanceof
- 연산자 우선순위 6: 등식 연산자 ==, !=
- 연산자 우선순위 7: 비트 연산자 &, ^, |
- 연산자 우선순위 8: 논리 연산자 &&, ||
- 연산자 우선순위 9: 삼항 연산자 ? :
- 연산자 우선순위 10: 대입 연산자 =, +=, -=, *=, /=, %=
- 문자열의 비교는 .equals() 메서드를 사용해야 한다.
- ctrl+shift+enter: 문장 완성 단축키
- 논리 연산자 && 그리고: 두 피연산자가 모두 참이면 참을 반환
- 논리 연산자 || 또는: 두 피연산자 중 하나라도 참이면 참
- 논리 연산자 ! 부정: 피연산자의 논리적 부정을 반환
- 축약(복합) 대입 연산자: 연산 후 대입
- instanceof 연산자: 객체 타입을 확인한다.
- [] 배열 인덱스 연산자
- . 객체 멤버 접근 연산자
- () 메소드 호출 연산자
- 비트 연산자: &, |, ^, ~, <<, >>, >>>
- 조건문: if문, switch문
- case에 break가 없으면 break를 만날 때까지 다음 case를 실행한다.
- 반복문: while문, do-while문, for문
- while문 안의 if문 안의 break: while문 종료한다.
- continue는 반복문의 조건식으로 돌아간다.
- for문: 초기식(1번) -> 조건식 -> 코드 -> 증감식 -> 조건식 -> ...
- for문에서 초기식, 조건식, 증감식은 선택이다. 생략 시 세미콜론 유지한다.
- for (;;): 무한 반복하는 while (true)와 같다.
- 선언한 위치에 따라 지역 변수, 멤버 변수(클래스 변수, 인스턴스 변수)로 분류
- 지역 변수의 지역: 변수가 선언된 코드 블록 {} = 지역 변수의 스코프
- 변수의 접근 가능한 범위를 스코프라고 한다.
- 조건문, 반복문 등 어떤 블록 안에서만 사용되는 변수를 블록 안에서 선언하는 것이 좋다.
- 밖에서 선언하면 메모리가 낭비되고, 블록 바깥 시점에서도 그 변수를 고려해야 한다.
- Ctrl + E 누른 후 엔터: 바로 이전에 작업하던 .java 파일 창이 열린다.
- int -> long -> double: 작은 범위에서 큰 범위로는 값을 대입할 수 있다.
- 큰 범위에서 작은 범위로는 소수점 버림, 오버플로우 문제가 (데이터 손실되는) 발생할 수 있다.
- 디컴파일 보면 longValue = (long)intValue; 이렇게 (long)이 자동으로 붙는다.
- doubleValue = 20L; -> doubleValue = (double)20.0F; 이렇게 디컴파일 된다.
- doubleValue = 1.5; -> doubleValue = (double)1.5F; 이렇게 디컴파일 된다.
- doubleValue2 = 1.12345678901234567890; -> = 1.1234567890123457; 된다.
- 작은 범위에서 큰 범위로는 자동 형변환 된다. 반대로는 명시적 형변환이 필요하다.
- intValue = doubleValue; 컴파일 오류 발생한다. = (int)doubleValue; 이렇게 한다.
- long maxIntOver = 2147483648; //int 최대 + 1 리터럴 기본은 int다.
- maxIntOver가 저장은 되지만, 2147483648에 Integer number too large가 뜬다.
- = (long)2147483648;도 안 되고, = 2147483648L;만 된다.
- 디컴파일 보면, long maxIntValue = 2147483647L;는 자동으로 된다.
- long maxIntOver = 2147483648L;는, 명시해서만 된다.
- 정리하면, 정수 리터럴은 기본적으로 int 타입이라서 2147283648을 int로 해석하려고 시도한다.
- int 범위를 벗어나는 수이므로, 컴파일러가 오류를 발생시킨다.
- (long)이 붙어 있어도, int 범위를 초과하면 컴파일러가 리터럴 자체에서 오류를 발생시킨다.
- 리터럴의 타입 분석 후 형변환이 작동한다.
- intValue3 = (int)2147483648L; //-2147483648이다. 시계 도는 것처럼 오버플로우 처리
- 오버플로우 해서 어떤 값이 되는지가 아닌, 오버플로우 발생 방지 위한 큰 타입으로 변경이 중요하다.
- 3 / 2를 double에 저장하면 1, 3.0 / 2과 (double)3 / 2를 double에 저장하면 1.5가 된다.
- 같은 타입끼리의 계산은 같은 타입의 결과를 내고, 다른 타입끼리의 계산은 큰 범위로 피연산자를 형변환한다.
- 디컴파일에는 = (double)1.0F;, = (double)1.5F; 이렇게 계산 결과가 써 있다.
- intValue = true; //컴파일 오류 발생. 타입 제약이 있어야 한다.
- Scanner 클래스를 활용하면 System.in 사용자 입력을 편리하게 받을 수 있다.
- 반복문 안에서 str = scanner.nextLine(); 할 때도 String str을 매번 선언하는 게 낫다.
- Rename 단축키: 커서 두고, Shift + F6, 바꾸고 엔터
- scanner.nextInt();에서 사용자가 1(엔터) 입력하면 버퍼에 "1\n" 저장됨
- nextInt();가 1만 읽고, 버퍼에 \n을 남긴다.
- 다음에 nextLine();이 실행되면, 바로 \n을 읽어서 빈줄 입력으로 처리된다.
- nextInt(); -> nextLine();으로 버퍼 비운다. -> nextLine();
- 배열 변수 선언 + new로 배열 생성
- 배열 생성 시 자동 초기화: 숫자는 0, boolean은 false, String은 null
- new int[5]로 배열 생성하면 4byte * 5 = 20byte 메모리 확보
- 배열 생성 시 배열에 접근하는 참조값으로서 주소를 반환: 배열 변수가 저장하는 값
- [I@5b6f7412 //[I는 int형 배열을 뜻한다. 5b~부분이 16진수 메모리 참조값
- 즉, 참조값 + 인덱스로 해당 위치의 요소에 접근한다.
- 배열 유효 범위를 벗어나는 인덱스를 사용하면 런타임 오류가 발생한다.
- 범위를 벗어나면 실행 중 'ArrayIndexOutOfBoundsException' 예외가 발생합니다.
- 기본형 데이터: int, boolean 등 변수에 사용할 값 직접 넣을 수 있는 타입
- 참조형 데이터: 데이터에 접근하는 참조 주소 저장하는 타입 (배열, 객체, 클래스 변수)
- 기본형은 사이즈가 정해져 있지만, 참조형은 동적으로 메모리 할당이 가능하다.
- int[] students = new int[3]{90, 80, 70}; //컴파일 에러: 길이 지정과 초기값 동시 사용 금지
- int[] students = new int[]{90, 80, 70}; //사용 가능
- int[] arr; -> arr = new int[]{90, 80, 70}; //사용 가능
- int[] arr = {1, 2, 3}; //배열 선언과 동시에 초기화할 때만 new 생략 가능
- int[][] arr = new int[2][3]; -> arr = new int[][]{{1, 2, 3}, {4, 5, 6}};
- int[][] arr = new int[][]{{1, 2, 3}, {4, 5, 6}};
- int[][] brr = {{7, 8, 9}, {10, 11, 12}};
- 2차원 배열 이중 for문: row < arr.length -> col < arr[row].length
- 향상된 for(for-each)문: 오른쪽 배열의 값을 순회한다. 왼쪽이 값을 지칭한다.
- iter + 엔터해서 배열 고르면 for-each문 생성된다.
- 향상된 for문은 증가하는 인덱스가 감춰져 있다.
- 향상된 for문은 값 복사라서 배열 값을 수정할 수 없다.
- 메서드 제어자: public static과 같은 부분
- 메서드 반환 타입: 메서드 실행 후 반환하는 데이터 타입. 반환 안 하면 void
- 메서드 이름: 메서드 호출 시 사용
- 메서드 매개변수: 값을 입력해서 메서드 내부에서 사용할 수 있는 변수.
- 호출 시 넘기는 값 "hello"를 인자, 정의 시 선언한 String str를 매개변수라 한다.
- 메서드 본문: 실행 코드. return에서 해당 메서드는 종료된다.
- return 실행이 보장이 안 되면 return문을 누락했다는 컴파일 오류가 발생한다.
- 중요한 대원칙: 자바는 항상 변수의 값을 복사해서 대입한다.
- 메서드 호출할 때도 형변환이 적용된다. int에 double 값 전달하려면 (int) 명시한다.
- 메서드 오버로딩: 이름이 같아도 매개변수 타입과 순서가 다르면 오버로딩 할 수 있다.
- 순서 다르다란 add(int a, string b)!=add(string b, int a)를 말한다.
- add(int a, int b)와 add(int c, int d)는 순서 같다. 오버로딩 할 수 없다.
- add(int a)와 add(int a, int b)는 오버로딩 할 수 있다.
- 메서드 오버로딩: 이름, 매개변수 같고 반환 타입만 다르면 오버로딩 할 수 없다.
- (int, double)과 (double, int) 있는데 (1, 1)이나 (1.0, 1.0) 쓰면 컴파일 오류난다.
- 오버로딩 충돌 (ambiguity)이라고 한다. 메소드 하나만 있으면 (1, 1)은 자동 형변환 실행된다.
- (1.0, 1.0)의 경우 메소드 하나만 있어도 double -> int에서 명시적 형변환 필요하다.
- 변수 이름은 명사를 사용하고, 메서드 이름은 동사로 시작한다. 이외의 규칙은 같다.
- 변수 이름 예: customerName, totalSum, employeeCount, isAvailable
- 메서드명 예: printReport(), calculateSum(), getEmployeeCount()
- 메서드 사용의 장점: 특정 기능을 캡슐화헤서 코드 재사용 가능
- 코드 가독성 향상, 모듈성 (부분으로 독립적으로 나눔)
- 코드 유지 관리, 테스트 및 디버깅 용이성
- 다른 프로그램에서 재사용 및 확장성, 추상화 (사용 시 구현 몰라도 됨)
---