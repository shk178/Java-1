각 상태 코드를 실제 웹에서 자주 겪는 상황 중심으로 아주 쉽게 예시를 들어 설명해줄게.
복잡한 설명 대신 “어떤 상황에서 나오는지”만 딱 이해할 수 있도록 정리했다.

---

# 1xx 정보(거의 안 봄)

### 100 Continue

* 파일 업로드 같은 큰 요청을 보내기 전에 "계속 보내도 된다"는 신호
  → 일반 웹 개발에서는 거의 보지 않음

---

# 2xx 성공

### 200 OK

* 요청이 정상적으로 처리됨
  예:

```
GET /members/1
→ 회원 정보 정상 조회됨
```

---

### 201 Created

* 새로운 데이터가 성공적으로 생성됨
  예:

```
POST /members
→ 새 회원 생성됨
```

서버는 위치(Location) 헤더로 새 리소스 URL도 알려줌

```
Location: /members/10
```

---

### 204 No Content

* 요청은 성공했는데 응답 본문은 필요 없음
  예:

```
DELETE /members/10
→ 삭제 성공, 보낼 데이터 없음
```

---

# 3xx 리다이렉션

### 302 Found

* “다른 URL로 잠깐 이동해라”
  예:

```
POST /members
→ 성공 후 /members 목록 페이지로 이동시키는 경우
```

---

### 303 See Other

* POST 처리 후 GET으로만 조회하라고 지시
  예:

```
POST /members
→ 303 응답
→ 클라이언트가 자동으로 GET /members 로 이동
```

---

### 304 Not Modified

* 서버 데이터 변경 없음 → 캐시 사용
  예:

```
GET /logo.png (ETag 포함)
→ 변경 없음 → 304
→ 브라우저는 로컬 캐시 사용
```

---

# 4xx 클라이언트 오류

### 400 Bad Request

* 요청 형식 자체가 잘못됨
  예:

```
POST /members
Content-Type: application/json

"name": "kim"   (JSON이 깨짐)
→ 400
```

---

### 401 Unauthorized

* 인증 필요 (로그인 필요)
  예:

```
GET /mypage
→ 로그인 안 했음 → 401
```

---

### 403 Forbidden

* 로그인은 했는데 권한 없음
  예:

```
DELETE /admin/settings
→ 일반 유저가 접근 → 403
```

---

### 404 Not Found

* URL이 틀렸거나 데이터가 없음
  예:

```
GET /members/9999
→ 이런 회원 없음 → 404
```

또는 단순 오타:

```
GET /memeber
→ 잘못된 경로 → 404
```

---

### 405 Method Not Allowed

* URL은 존재하는데 허용되지 않은 HTTP 메서드
  예:

```
GET /members (OK)
POST /members (OK)
PUT /members  → 405 (컬렉션 전체 수정은 허용 안 함)
```

또는:

```
POST /members/new
→ 이 URL은 GET 화면만 있으므로 405
```

---

### 409 Conflict

* 요청은 맞는데 서버의 현재 상태와 충돌
  예:

```
POST /members
→ 이메일 중복으로 회원 생성 불가 → 409
```

또는 버전 충돌(동시 수정 문제)도 409 사용.

---

### 429 Too Many Requests

* 너무 많은 요청(속도 제한 초과)
  예:

```
1초에 100번 API 호출 → 429
```

---

# 5xx 서버 오류

### 500 Internal Server Error

* 서버 내부에서 예외 발생
  예:
* DB 연결 오류
* NullPointerException
* 서버 코드 버그

→ 개발자가 해결해야 하는 문제

---

### 502 Bad Gateway

* 서버 앞단의 프록시/CDN이 백엔드 서버로부터 잘못된 응답을 받음
  예:

```
Cloudflare → API 서버 응답 못 받음 → 502
```

---

### 503 Service Unavailable

* 서버 과부하 또는 점검 중
  예:

```
트래픽 폭주 → 서버 다운 → 503
```

---

### 504 Gateway Timeout

* 앞단 서버(nginx 등)가 백엔드로부터 시간 안에 응답을 못 받음
  예:

```
DB 응답이 너무 느려서 타임아웃 → 504
```

---

# 한눈에 보기 요약

| 코드  | 언제 나옴?            |
| --- | ----------------- |
| 200 | 정상 조회             |
| 201 | 정상 생성             |
| 204 | 정상 삭제 등, 응답 없음    |
| 302 | POST 후 다른 페이지로 이동 |
| 304 | 캐시 사용(변경 없음)      |
| 400 | 요청 형식 오류          |
| 401 | 로그인 필요            |
| 403 | 권한 없음             |
| 404 | URL/데이터 없음        |
| 405 | 메서드 잘못됨           |
| 409 | 중복 데이터 등 충돌       |
| 429 | 너무 많은 요청          |
| 500 | 서버 내부 오류          |
| 503 | 서버 과부하/점검         |
| 504 | 백엔드 응답 지연         |

---

원하면

* 상황별로 어떤 상태코드를 선택해야 하는지 가이드
* Spring Boot에서 상태 코드 바꾸는 방법
* REST API 설계에서 잘못 쓰기 쉬운 상태 코드들
  도 이어서 설명해줄게.

POST 새로고침 문제가 생기지 않도록 리다이렉션으로 막는 방식을 PRG 패턴(Post–Redirect–Get) 이라고 한다.
여기서 POST 요청 후 302 또는 303 리다이렉트가 발생한다.
왜 필요한지, 어떤 원리인지 차근차근 설명할게.

---

# 1. 문제: POST 요청은 새로고침하면 “다시 POST”된다

예를 들어 회원 등록 요청을 보냈다고 해보자.

```
POST /members
(name=kim)
```

서버는 등록을 완료하고 화면에 “등록 완료” 같은 HTML을 내려줌.
그 상태에서 사용자가 새로고침(F5)을 누르면 브라우저는 이렇게 묻는다:

```
이전 요청을 다시 제출할까요?
```

왜냐하면 브라우저는 직전 요청이 POST임을 기억하고 있으므로,
새로고침 = POST 데이터를 다시 제출하는 동작이 되기 때문이다.

### 결과

* 회원이 또 생성됨 (중복 등록)
* 글이 또 작성됨 (중복 게시글)
* 주문이 또 들어감 (중복 결제… 아주 위험)

이게 *POST 새로고침 문제*다.

---

# 2. 해결책: POST 이후에는 “리다이렉트”로 강제로 GET으로 바꾼다 (PRG 패턴)

서버가 POST 요청을 받으면 이렇게 처리한다:

```
POST /members
→ (회원 생성)
→ 302 Found or 303 See Other
→ Location: /members
```

즉 바로 HTML 화면을 내려주는 게 아니라, 리다이렉트 응답을 보낸다.

### 브라우저 동작

리다이렉트 응답을 받으면:

1. POST 요청 처리 완료
2. 서버가 알려준 Location URL로 자동 GET 요청을 보냄

```
GET /members
```

이렇게 되면 사용자가 새로고침을 눌러도 다음 요청만 반복된다:

```
GET /members
```

즉, 새로고침 시 GET만 반복되므로 POST가 다시 발생하지 않는다.
→ 중복 제출 방지

---

# 3. 이 패턴을 왜 “Post–Redirect–Get”이라고 부르는가?

1. Post
   사용자가 form을 제출한다.

2. Redirect
   서버는 처리 후 화면을 직접 보여주는 대신
   리다이렉트(302/303) 응답만 보낸다.

3. Get
   브라우저가 새 URL로 자동 GET 요청을 보내고
   그 GET 페이지가 화면에 표시된다.

이런 흐름이기 때문에 PRG라고 한다.

---

# 4. 왜 꼭 필요한가?

## 1) 중복 제출 방지

앞에서 설명한 것처럼
POST 새로고침 = 다시 POST
→ 중복 데이터 생성

PRG 사용 시
POST 새로고침 = GET
→ 안전

## 2) URL의 정합성

POST 처리 후 사용자가 북마크하면
POST URL을 저장해버리기 때문에 문제가 생길 수 있다.

하지만 리다이렉트 후 GET 페이지는 URL이 정상적이다.

| 상황                  | 문제                           |
| ------------------- | ---------------------------- |
| POST 후 HTML을 바로 내려줌 | 북마크하면 POST URL 저장됨, 재접속 시 오류 |
| PRG 사용              | GET URL을 북마크하므로 정상           |

## 3) 브라우저 경험 개선

POST 새로고침 경고창이 사라짐.
UX가 매끄러워진다.

---

# 5. 어떤 리다이렉션을 쓰는가?

### 302 Found

전통적
POST 이후 리다이렉션에서 많이 쓰임
브라우저가 POST → GET으로 자동 변경

### 303 See Other

POST 처리 후 반드시 GET으로 전환하라는 의미가 더 명확
요즘 REST/MVC 패턴에서는 303이 의미상 더 정확함

둘 다 PRG에 널리 사용된다.

---

# 6. Spring MVC에서 어떻게 하는가?

### 컨트롤러에서 이렇게 작성하면 자동 PRG:

```java
@PostMapping("/members")
public String save(MemberForm form) {
    memberService.save(form);
    return "redirect:/members";  // PRG 자동 적용
}
```

Spring은 `redirect:` 가 있으면 302 응답을 자동 생성한다.

---

# 7. 핵심 요약

### 문제

POST 새로고침 → 또 POST → 중복 제출

### 해결

POST 처리 후 바로 화면을 보내지 않고
302/303 응답으로 리다이렉트 → GET으로 전환

### 결과

새로고침은 GET만 반복 → 중복 제출 방지

### 이름

PRG 패턴(Post–Redirect–Get)

---

원하면 이어서

* 리다이렉트 vs 포워드 차이
* 302와 303 어느 상황에서 쓰는지
* Spring Boot에서 상태 코드 직접 설정 방법
  도 설명해줄게.

POST-Redirect-GET(PRG) 패턴에서 사용하는 리다이렉션은 항상 “일시적(temporary) 리다이렉트”다.
영구 리다이렉트는 절대 사용하면 안 된다.

이유와 근거를 아주 명확히 설명해줄게.

---

# 1. PRG에서 사용하는 리다이렉트는 “일시적 리다이렉트”

PRG에서는 보통 다음 상태 코드를 사용한다.

* 302 Found (전통적, 가장 널리 사용)
* 303 See Other (POST 이후 GET 전환을 명확히 지시)
* 때로는 307 Temporary Redirect (메서드 유지하는 경우)

이 셋은 모두 일시적 리다이렉트다.

---

# 2. 왜 일시적이어야 할까?

## 이유 1) POST 처리 후 이동하는 URL은 “영구”가 아니다

POST 처리 후 `/members` 같은 목록 페이지로 보내는 것은
그 순간 사용자를 페이지 흐름으로 보내기 위한 임시 조치일 뿐이다.

이것은 “페이지가 영구 이동했다”는 의미가 전혀 아니다.

---

## 이유 2) 301(영구 리다이렉트)을 쓰면 브라우저가 기억해버림

301 Moved Permanently를 쓰면 브라우저는:

* 이 URL은 평생 다른 곳으로 이동된 것이라고 저장한다.
* 다음에 사용자가 같은 URL을 치면 바로 리다이렉트된 곳으로 이동한다(서버까지 안 감).

PRG 상황에서 이런 동작은 완전히 잘못된 흐름을 만든다.

예:

```
POST /members    ← 등록 처리
→ 301 Moved Permanently to /members
```

브라우저는 다음부터 /members로 바로 가버림
→ POST URL을 다시 쓸 수 없음
→ 폼 제출 흐름이 망가짐
→ 디버깅도 어려워짐

---

## 이유 3) PRG의 목적은 “중복 제출 방지”이지 “URL 변경 영구화”가 아님

PRG는 화면 흐름을 안전하게 만들기 위한 것일 뿐,
리소스의 URL이 바뀌었다는 의미가 아니다.

따라서 temporary redirect가 100% 맞다.

---

# 3. 정리

| 상태 코드   | 성격  | PRG에서 사용 가능? | 이유                   |
| ------- | --- | ------------ | -------------------- |
| 302 | 일시적 | ✔            | POST → GET 전환용       |
| 303 | 일시적 | ✔ (권장)       | POST 후 반드시 GET으로 전환  |
| 307 | 일시적 | 조건부          | 메서드 유지, 일반 PRG에는 비권장 |
| 301 | 영구적 | ✘            | 브라우저가 기억해버려 동작이 망가짐  |
| 308 | 영구적 | ✘            | 301과 동일 문제           |

---

# 결론

PRG에서는 항상 “일시적 리다이렉트(302, 303, 307)”를 사용한다.
영구적 리다이렉트는 절대로 쓰면 안 된다.

필요하면

* 302 vs 303 차이
* 307/308이 왜 생겼는지
* Spring MVC에서 303을 강제로 쓰는 방법
  도 이어서 설명해줄게.

영구적 리다이렉트(301, 308)는 특정 URL이 아예 다른 URL로 “영구히 바뀌었을 때” 사용하는 것이다.
즉, “이제부터는 이 주소로 오지 말고 저 주소로 와라”를 서버가 선언하는 것이다.

그리고 영구/일시적이라는 구분은 오직 서버가 선언하는 것이고,
브라우저는 그 선언을 보고 행동을 바꾸는 것이다.

아래에서 명확하게 정리해줄게.

---

# 1. 영구적 리다이렉트(301, 308)는 언제 쓰는가?

## 1) 페이지 주소가 진짜로 바뀌었을 때

예:

* 과거 URL: `/home`
* 새 URL: `/main`

사이트 구조 개편으로 URL이 바뀐 경우:

```
GET /home
→ 301 Moved Permanently
Location: /main
```

이제 /home은 영원히 /main으로 이동했다는 의미가 된다.

---

## 2) 도메인 자체가 바뀐 경우

예:

* 옛날 사이트: `example.com`
* 새 사이트: `example.org`

```
GET http://example.com
→ 301 Location: https://example.org
```

브라우저는 이후부터 `/`를 칠 때 `example.org`로 자동 이동한다.

---

## 3) HTTP → HTTPS로 완전 전환할 때

웹사이트 전체를 HTTPS로 강제하려고 할 때:

```
GET http://my-site.com
→ 301 Location: https://my-site.com
```

이 경우는 매우 흔하게 사용된다.

---

## 4) SEO(search engine optimization) 목적

검색엔진에게도 “여기가 새로운 공식 URL이다”라고 알려주기 때문에
검색 엔진 순위 유지·이동에도 필요하다.

즉, 301은 검색엔진까지도 새 URL로 업데이트하라는 신호다.

---

# 2. 반대로 사용하면 안 되는 상황

## 1) PRG 패턴(POST-Redirect-GET)에서

절대로 301을 쓰면 안 된다.
사용자가 그 URL로 다시 오면 곧바로 GET으로 가서 정상 동작이 망가진다.

---

## 2) 임시 화면 이동, 기능 흐름 이동

예:

* 로그인 후 대시보드로 이동
* 댓글 작성 후 목록으로 이동

이런건 전부 “일시적 이동”이므로 302/303을 사용해야 한다.

---

# 3. “영구적/일시적”은 누구 관점인가?

질문: 영구적/일시적이라는 게 서버 측면에서야?
정확히 말하면,

### 서버가 “이 URL은 영구 이동인지 일시 이동인지” 선언하고

### 브라우저가 그 선언을 보고 행동을 바꾼다.

즉:

### 1) 서버 관점

“우리는 앞으로 이 URL을 쓰지 않습니다. 사용자를 새 URL로 안내합니다.”

이를 영구적으로 선언하면 301, 308을 쓴 것이다.
일시적으로 선언하면 302, 303, 307을 쓴 것이다.

### 2) 브라우저 관점

서버의 선언에 따라 행동이 달라짐.

* 301(영구):

    * 브라우저는 캐시에 저장한다.
    * 이후 같은 URL로 가면 서버에 가지 않고 바로 새 URL로 이동한다.

* 302/303(일시):

    * 브라우저는 캐시 저장하지 않는다.
    * “일시적으로 옮겨지는구나”라고만 인식한다.

---

# 4. 영구/일시는 “URL의 미래 운명”을 서버가 선언하는 것

정리하면:

| 리다이렉트 종류               | 의미           | 브라우저 동작                      |
| ---------------------- | ------------ | ---------------------------- |
| 301, 308 (영구)      | URL이 완전히 변경됨 | 브라우저가 기억하고 다음부터 직접 새 URL로 이동 |
| 302, 303, 307 (일시) | 지금만 이쪽으로 가라  | 브라우저는 기억하지 않음                |

PRG 패턴, 로그인 후 이동 등은 모두 “일시적인 이동”이므로 302/303.

영구 URL 변경, HTTPS 전환은 301.

---

# 결론

* 영구적 리다이렉트는 URL이 진짜로 바뀐 상황에서만 사용한다.
* 변경된 URL을 브라우저와 검색 엔진이 영구적으로 기억하게 하기 위함이다.
* PRG 같은 요청 흐름 처리에는 절대 사용하면 안 된다.
* “영구/일시”는 서버가 선언하는 개념이며, 브라우저는 그 선언에 따라 행동을 바꾼다.

원하면

* 301과 308의 차이
* 302 vs 303 정확한 구분
* Spring Boot에서 리다이렉트 코드 직접 지정하는 방법
  도 이어서 설명해줄게.

맞아.
리다이렉트란 “서버가 브라우저에게 ‘이 URL로 다시 요청해라’라고 명령하는 응답 메시지를 보내는 것”이다.
브라우저는 그 명령을 받고 자동으로 GET 요청을 다시 보낸다.
그 원리를 아주 구체적으로 설명해줄게.

---

# 1. 리다이렉트는 “Location 헤더가 있는 응답”이다

서버는 클라이언트에게 다음과 같이 응답을 보낸다:

```
HTTP/1.1 302 Found
Location: /members
```

또는:

```
HTTP/1.1 303 See Other
Location: /members
```

여기서 핵심은 Location 헤더다.

* 상태 코드 3xx
* Location: 새 URL

이 두 가지가 오면 브라우저는 다음 동작을 자동으로 수행한다:

> “아, 다른 URL로 다시 요청해야 하는구나.”

---

# 2. 브라우저가 자동으로 GET 요청을 만드는 과정

예를 들어 사용자가 다음 요청을 보냈다고 하자:

```
POST /members
```

서버는 등록 처리 후 이렇게 응답함:

```
HTTP/1.1 303 See Other
Location: /members
```

브라우저 동작 순서:

1. 서버 응답 받음
2. 응답 코드가 3xx인지 확인
3. Location 헤더가 있는지 확인
4. Location에 적힌 URL로 자동 요청 실행

    * 302/303 → 자동 GET으로 변환
    * 307/308 → 기존 메서드를 유지
5. 최종적으로 화면이 새 URL로 바뀜

즉, 자동 요청은 브라우저가 하는 것이고
서버는 Location 헤더만 보내면 된다.

---

# 3. 그렇다면 “브라우저가 GET을 보내는 시점”은 언제일까?

서버가 3xx + Location을 보내는 순간
브라우저는 응답을 렌더링하지 않는다.

대신 이렇게 한다:

* “응답을 화면에 표시하는 단계” → 건너뜀
* “리다이렉트 대상 URL로 요청 보내는 단계” → 실행

그 결과
브라우저가 두 번 요청을 보낸 것처럼 보이게 된다.

1. 첫 번째 요청: 사용자의 원래 요청
2. 두 번째 요청: 브라우저가 자동으로 보낸 GET 요청

---

# 4. 그러면 서버는 어떻게 코드로 리다이렉트를 보낼까?

## Spring MVC 예시

```java
@PostMapping("/members")
public String save(MemberForm form) {
    memberService.save(form);
    return "redirect:/members";
}
```

이렇게만 적어도 Spring이 내부적으로 다음 응답을 만든다:

```
HTTP/1.1 302 Found
Location: /members
```

브라우저는 GET /members를 자동 요청.

---

# 5. 다시 정리하면

### ✔ 리다이렉트 = 브라우저에게 “저기로 가라”라고 명령하는 응답

### ✔ 서버는 응답 메시지에 상태 코드 + Location 헤더만 넣으면 된다

### ✔ 브라우저는 그걸 해석해서 자동으로 GET(또는 필요 시 다른 메서드)로 요청한다

### ✔ 그래서 화면이 자동으로 이동하는 것처럼 보인다

---

# 6. 아주 직관적인 비유

* 서버: “여기 말고 저쪽 창구로 가세요! 주소는 이거예요.”
* 브라우저: “네, 그 주소로 다시 갑니다.” (자동)

---

원하면

* 302/303/307/308에서 브라우저가 어떤 요청을 자동으로 보내는지 차이
* 브라우저의 리다이렉트 내부 동작 순서 전체
* PRG(Post-Redirect-Get) 흐름을 흐름도로 설명
  도 이어서 알려줄게.

“캐시로 인한 리다이렉트”는 브라우저가 과거에 받았던 리다이렉트 응답을 캐시에 저장해 두었다가,
서버에 가지 않고 스스로 리다이렉트를 반복 수행하는 것을 의미한다.

즉 리다이렉트 자체가 캐시되기 때문에 일어나는 현상이다.

아래에서 원리와 “언제 발생하는지”를 정리해줄게.

---

# 1. 리다이렉트도 캐시될 수 있다

리다이렉트는 결국 HTTP 응답이다.

리다이렉트 응답도 다음처럼 헤더를 가진 하나의 응답 메시지다:

```
HTTP/1.1 301 Moved Permanently   ← 영구 리다이렉트
Location: /new-home
```

브라우저는 이 응답을 보고
“/old-home은 앞으로 영원히 /new-home으로 이동한다”고 이해한다.

그리고 영구 리다이렉트(301, 308)는 브라우저가 캐시에 저장한다.

그 결과:

```
다음에 /old-home으로 요청 → 서버에 가지 않고 바로 /new-home으로 이동
```

브라우저 내부 캐시에서 자동 리다이렉트가 일어난다.

---

# 2. 어떤 리다이렉트는 캐시되고, 어떤 리다이렉트는 캐시되지 않는다

| 상태 코드   | 성격 | 브라우저 캐시? | 설명               |
| ------- | -- | -------- | ---------------- |
| 301 | 영구 | 저장함      | “앞으로 계속 이쪽으로 이동” |
| 308 | 영구 | 저장함      | 301과 비슷한 동작      |
| 302 | 일시 | 저장 안 함   | 지금만 이동           |
| 303 | 일시 | 저장 안 함   | POST→GET 명령용     |
| 307 | 일시 | 저장 안 함   | 메서드 유지 일시 이동     |

즉, 301/308만 캐시된다.

그래서 “캐시로 인한 리다이렉트”는 영구 리다이렉트에서만 발생한다.

---

# 3. 캐시된 리다이렉트가 일어나는 실제 예시

## 예: 사이트의 메인 주소를 바꿨을 때

서버가 이렇게 응답했다고 해보자:

```
GET /home
→ 301 Location: /main
```

브라우저는 이를 캐시한다.

이후:

```
GET /home
```

브라우저가 서버로 요청하는 것이 아니라:

```
(브라우저 내부) /home → /main 자동 이동
→ 서버로는 GET /main 요청만 날아감
```

서버는 /home 요청을 아예 받지 않는다.

---

# 4. 개발 과정에서 흔히 겪는 문제

## 문제 1) 잘못된 301 리다이렉트를 설정했는데 브라우저가 기억해버림

개발 중 URL을 잘못 301로 설정한 경우:

* 설정을 수정했는데도
* 브라우저가 계속 이전 301 규칙을 사용해서
  서버에 도달조차 하지 못한다.

해결:

* 브라우저 캐시 삭제
* 개발자 도구 → Disable cache
* 다른 브라우저로 테스트

---

## 문제 2) Load balancer/CDN이 리다이렉트를 캐시

Cloudflare/AWS CloudFront/CDN도 영구 리다이렉트를 캐시할 수 있다.

결과:

* 서버는 이미 설정을 바꿨는데
* CDN이 예전 301 응답을 계속 내보내 버린다.

---

# 5. PRG(Post-Redirect-Get)에서는 절대로 영구 리다이렉트를 쓰면 안 되는 이유

PRG는 사용자를 임시로 GET 페이지로 보내기 위한 흐름이다.
만약 여기서 301을 쓰면:

* 브라우저가 그 URL을 평생 기억한다
* 이후 POST 흐름이 망가진다
* 디버깅이 매우 어려워진다

그래서 PRG에서는 항상 302/303 사용.

---

# 6. 정리

1. “캐시로 인한 리다이렉트”란?
   브라우저가 과거의 301/308 응답을 기억해서
   서버에 가지 않고 자동으로 다른 URL로 이동하는 것.

2. 어떤 상태코드가 캐시되는가?
   301, 308 (영구)

3. 언제 필요하고 언제 위험한가?

    * 사이트가 진짜로 영구적으로 URL이 바뀔 때는 유용
    * 개발 환경에서는 캐시가 남아서 예상치 못한 이동이 발생할 수 있음
    * PRG에서는 절대 사용하면 안 됨

---

원하면 이어서

* 301과 308의 차이
* 브라우저가 리다이렉트를 캐시하는 정확한 조건
* 개발 도중 301 캐시 문제를 해결하는 구체적 방법
  도 자세히 설명해줄게.

- 401은 인증(로그인)이 필요하거나 실패했을 때, 403은 인증은 성공했지만 해당 리소스에 접근할 권한이 없을 때 사용돼요. '누구인지'와 '무엇을 할 수 있는지'의 차이랍니다.

맞아.
304 Not Modified는 “서버 데이터가 변경되지 않았으니, 브라우저는 네가 갖고 있는 캐시를 그대로 사용해라”라는 의미다.
단, 304는 “캐시를 사용하라”라고 직접 말하는 것이 아니라 “새 데이터 줄 필요 없다 → 네가 가진 캐시가 유효하다”라는 신호를 주는 것이다.

아주 정확히 정리해줄게.

---

# 1. 304는 “조건부 요청”에 대한 응답이다

브라우저가 캐시를 가지고 있을 때, 서버에게 이렇게 묻는다:

```
If-None-Match: "abc123"       ← ETag 버전
또는
If-Modified-Since: Tue, 07 Feb 2023 10:00:00 GMT
```

의미:

> 내가 이전에 받은 버전이 있는데, 그대로인가요? 바뀌었나요?

---

# 2. 서버가 확인 후, 바뀌지 않았다면 304 응답

서버가 확인해보니 데이터 변경이 없으면:

```
HTTP/1.1 304 Not Modified
```

→ 응답 바디 없음
→ “새 데이터 줄 필요 없고, 네 캐시를 계속 쓰면 된다”

브라우저는:

* 기존에 가지고 있던 캐시 파일 다시 사용
* 다운로드 발생하지 않음
* 화면은 빠르게 로딩됨

---

# 3. 서버 데이터가 바뀌었다면 200 OK + 새 데이터

만약 서버의 리소스가 변경되었다면:

```
HTTP/1.1 200 OK
(새로운 Content-Type, Response-Body 포함)
```

이제 브라우저는 새 데이터를 캐시에 갱신한다.

---

# 4. 핵심 요약

### ✔ 304 = “변경 없음 → 네 캐시 사용해도 정확하다”

* 서버는 본문(body)을 보내지 않음
* 브라우저는 기존 캐시 사용
* 네트워크 비용 절약

### ✔ 304는 캐시를 “지금 만들라”가 아니라,

### “이미 가진 캐시를 계속 써라”라는 뜻

---

# 5. 캐시를 사용하도록 하는 다른 것들과의 차이

| 방식                              | 역할                              |
| ------------------------------- | ------------------------------- |
| Cache-Control: max-age=3600 | 강력 캐시(아예 서버에 요청도 안 보냄)          |
| ETag / If-None-Match → 304  | 조건부 캐시(서버에 확인 요청만 보내고 필요하면 304) |
| 304 응답                      | “캐시 그대로 써라”라는 최종 신호             |

즉, 304는 “서버 확인 OK”를 뜻하는 신호다.

---

원하면

* ETag, Last-Modified 차이
* 강력 캐시 vs 조건부 캐시
* SPA 빌드 파일이 왜 캐시에 강하게 묶이는지
  도 쉽게 이어서 설명해줄게.

결론부터 말하면,

304(Not Modified)는 클라이언트도 서버도 “각자 역할을 정해줘야 동작한다.”
하지만 표준 규칙은 정해져 있어서 우리가 직접 ‘304를 보내라’고 강제로 구현할 필요는 없다.
클라이언트와 서버가 각자 정해진 HTTP 헤더를 사용하면 자동으로 이루어진다.

아래에서 정확히 정리해줄게.

---

# 1. 클라이언트(브라우저)는 조건부 요청 헤더를 자동으로 보낸다

브라우저는 캐시된 파일을 가지고 있으면 다음 기준에 따라 자동으로 조건부 요청을 보낸다.

### (1) ETag 기반 요청

```
If-None-Match: "abc123"
```

### (2) Last-Modified 기반 요청

```
If-Modified-Since: Tue, 07 Feb 2023 10:00:00 GMT
```

이 헤더들은 브라우저가 알아서 저장했다가,
서버에서 캐시 유효성을 체크하라고 보낸다.

즉,
클라이언트는 304용 헤더 규칙을 이미 가지고 있고 자동으로 보낸다.
개발자가 따로 코드를 짤 필요는 없다.

---

# 2. 서버는 “리소스가 변경되었는지” 판단하는 로직을 가져야 한다

서버는 위 조건부 요청을 받으면 다음 중 하나를 해야 한다:

### (1) 변경 없음 → 304 Not Modified

```
HTTP/1.1 304 Not Modified
(본문 없음)
```

이 경우 브라우저는 기존 캐시를 그대로 사용한다.

### (2) 변경 있음 → 200 OK + 새 데이터

```
HTTP/1.1 200 OK
ETag: "new123"
Last-Modified: ...
(새로운 파일/JSON 데이터)
```

즉, 서버는 ETag를 생성하거나 Last-Modified 시간을 계산하는 책임이 있다.
서버가 이 정보를 제공해야 클라이언트가 조건부 요청을 할 수 있다.

---

# 3. 서버가 자동으로 처리하는 경우가 많다

## 정적 파일(이미지, CSS, JS)

nginx, Apache, Spring Boot의 static resource handler는:

* ETag 자동 생성
* Last-Modified 자동 생성
* 조건부 요청 자동 비교
* 304 응답 자동 생성

즉, 스태틱 파일은 아무것도 설정 안 해도 304가 동작한다.

---

## 동적 데이터(JSON API)

동적 데이터는 서버 개발자가 직접 판단해야 한다.

방법은 두 가지:

### (1) 서버가 ETag를 만들어 응답에 넣는다

예:

```
ETag: "user123-v5"
```

그리고 다음 요청이 If-None-Match로 오면 비교 후 304 또는 200.

### (2) Last-Modified를 직접 넣는다

예:

```
Last-Modified: Tue, 07 Feb 2023 10:00:00 GMT
```

이 경우도 서버 로직이 필요하다.

---

# 4. 즉, "정의"는 이렇게 나뉜다

## ✔ 클라이언트(브라우저)는

* ETag·Last-Modified를 저장하고
* 조건부 요청(If-None-Match, If-Modified-Since)을 자동으로 보낸다
  → 이미 정의되어 있고, 개발자가 신경 쓸 필요 없음

## ✔ 서버는

* ETag 또는 Last-Modified를 설정해야 한다
* 조건부 요청이 오면 변경 여부 판단을 해야 함
  → 이게 있어야 304가 가능

---

# 5. 둘 다 역할을 한다

304는 “서버와 클라이언트가 같이 협력해야 작동하는 캐시 메커니즘”이다.

* 서버: ETag/Last-Modified 제공
* 클라이언트: 조건부 요청 헤더 전송
* 서버: 변경 여부 판단 후 304 or 200

모두 표준 HTTP 규칙이라 자율적이며,
우리가 “304를 만들겠다”라고 별도로 선언하는 것은 아니다.

---

# 결론

### ✔ 304를 사용하려면 서버 쪽에서 ETag 또는 Last-Modified를 제공해야 한다

### ✔ 브라우저는 이를 기반으로 자동으로 조건부 요청을 보낸다

### ✔ 서버가 요청을 보고 304 또는 200을 판단한다

### ✔ 개발자는 동적 데이터(API)에서만 ETag/Last-Modified를 구현하면 된다

원하면

* ETag를 직접 생성하는 방법(SHA-256 vs 버전 번호)
* Spring Boot에서 스태틱 파일 캐싱이 자동으로 되는 과정
* 강력 캐시 vs 조건부 캐시 차이
  등도 더 설명해줄게.

CRUD(데이터 생성·조회·수정·삭제)만 보면 단순해 보이지만,
HTTP API 관점에서는 CRUD가 “행동의 종류”일 뿐이고, 상태 코드는 “그 행동의 결과”다.
둘은 다른 역할을 하며, 서로를 보완한다.

즉,

* CRUD = 무엇을 하려는가(행위)
* 상태 코드 = 그 행위가 어떻게 끝났는가(결과)

그래서 CRUD를 한다고 해서 모든 상태 코드를 다 신경 써야 한다는 뜻은 아니다.
하지만 CRUD 작업마다 적절한 상태 코드를 선택해야 API가 명확해진다.

아래에서 이를 쉽게 정리해볼게.

---

# 1. CRUD와 상태 코드는 다른 층위의 개념이다

## CRUD(행위)

* Create
* Read
* Update
* Delete

즉 “리소스를 어떻게 조작할 것인가”를 표현한다.

## HTTP 상태 코드(결과)

* 성공인지 실패인지
* 새로 만들었는지
* 데이터가 없었는지
* 클라이언트 요청이 잘못됐는지
* 서버가 문제인지
* 캐시를 써도 되는지

같은 요청 처리의 결과 상태를 숫자로 표현한다.

---

# 2. CRUD → 어떤 상태 코드를 쓰는 게 적절한가?

CRUD를 하려면 “요청이 어떻게 끝났는지” 알려줘야 한다.
그래서 각 CRUD에 맞는 대표적인 상태 코드가 있다.

## 1) Create (생성)

```
POST /members
```

* 성공 → 201 Created
  (새 리소스가 만들어짐)
* 실패 → 400(잘못된 요청), 409(중복), 500(서버 오류)

---

## 2) Read (조회)

```
GET /members/1
```

* 성공 → 200 OK
* 리소스 없음 → 404 Not Found
* 인증 필요 → 401
* 권한 없음 → 403

---

## 3) Update (수정)

```
PUT /members/1
```

* 성공 → 200 OK (수정된 데이터 반환)
* 또는 204 No Content (본문 없이 성공만 알림)
* 대상 없음 → 404
* 요청 형식 오류 → 400
* 충돌 → 409

---

## 4) Delete (삭제)

```
DELETE /members/1
```

* 성공 → 204 No Content (응답 본문 없음이 일반적)
* 대상 없음 → 404
* 권한 없음 → 403

---

# 3. 왜 상태 코드가 중요할까?

같은 CRUD라도 결과가 항상 같지는 않기 때문이다.

예를 들어:

### “조회” 요청을 보냈다

* 회원이 있으면 → 200
* 회원이 없으면 → 404
* 인증이 필요하면 → 401
* 권한이 없어 접근 불가하면 → 403

모두 같은 CRUD “조회”인데, 상태는 전부 다르다.

### “생성” 요청을 보냈다

* 데이터 정상 생성 → 201
* 값이 잘못됨 → 400
* 중복 이메일 → 409
* 서버 오류 → 500

즉, CRUD는 행동이고, 상태 코드는 결과다.

---

# 4. “모든 상태 코드를 고려해야 하나?”

반드시 모든 코드를 고려할 필요는 없다.
실무에서 CRUD 기반 REST API를 만들 때 자주 쓰는 상태 코드 세트만 잘 선택하면 충분하다.

### 필수적으로 알아야 하는 것

* 200 OK
* 201 Created
* 204 No Content
* 400 Bad Request
* 401 Unauthorized
* 403 Forbidden
* 404 Not Found
* 409 Conflict
* 500 Internal Server Error

이 정도면 95% 상황을 커버한다.
나머지는 상황별로 필요할 때 적용하는 정도다.

---

# 5. 결론

* CRUD는 “무엇을 할 것인지”
* 상태 코드는 “어떻게 끝났는지”
* CRUD와 상태 코드는 서로 보완적인 관계
* 모든 상태 코드를 고려할 필요는 없고, CRUD 작업별로 알맞은 코드만 선택해주면 된다

원하면

* REST API 설계에서 가장 알맞은 상태 코드를 고르는 방법
* Spring MVC에서 상태 코드를 설정하는 방법
* 상태 코드 오용 사례(예: 200을 남발하는 경우)
  도 이어서 설명해줄게.
