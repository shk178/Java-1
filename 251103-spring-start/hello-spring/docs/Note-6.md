## Generic H2 (Embedded)
- 드라이버 클래스: org.h2.Driver
- JDBC URL: jdbc:h2:~/test
- 사용자명: sa
## Generic H2 (Server)
- 드라이버 클래스: org.h2.Driver
- JDBC URL: jdbc:h2:tcp://localhost/~/test
- 사용자명: sa
# H2 데이터베이스 테이블 없음 에러 해결
## 에러 발생 상황
회원 가입이나 회원 목록 기능을 실행할 때 다음과 같은 에러가 발생했습니다:
```
org.h2.jdbc.JdbcSQLSyntaxErrorException: Table "MEMBER" not found (this database is empty); SQL statement:
select * from member [42104-232]
```
## 에러 원인
### 1. 상황 분석
- `JdbcMemberRepository`를 사용하여 H2 데이터베이스에 접근하고 있음
- `sql/ddl.sql` 파일에 테이블 생성 DDL이 존재함
- 하지만 데이터베이스에 실제 테이블이 생성되지 않음
### 2. 근본 원인
Spring Boot가 SQL 스크립트를 자동으로 실행하도록 설정되어 있지 않습니다.
현재 설정 확인:
- `application.properties`에 SQL 스크립트 자동 실행 설정이 없음
- `sql/ddl.sql` 파일은 존재하지만 실행되지 않음
### 3. 에러 발생 위치
에러가 발생한 위치:
1. 회원 목록 조회 시: `JdbcMemberRepository.findAll()` → `select * from member`
2. 회원 가입 시: `JdbcMemberRepository.findByName()` → `select * from member where name = ?`
   두 경우 모두 `MEMBER` 테이블이 존재하지 않아서 발생한 에러입니다.
## 해결 방법
### 방법 1: Spring Boot 자동 SQL 실행 설정
`application.properties`에 다음 설정을 추가합니다:
```properties
# SQL 스크립트 자동 실행 설정
spring.sql.init.mode=always
spring.sql.init.schema-locations=classpath:schema.sql
```
주의사항:
- `schema.sql` 파일을 `src/main/resources/schema.sql` 경로에 생성해야 함
- 또는 `sql/ddl.sql` 파일을 `src/main/resources/schema.sql`로 복사
### 방법 2: resources 폴더에 schema.sql 생성
1. `sql/ddl.sql`의 내용을 복사
2. `src/main/resources/schema.sql` 파일 생성
3. `application.properties`에 설정 추가:
```properties
spring.sql.init.mode=always
spring.sql.init.schema-locations=classpath:schema.sql
```
schema.sql 내용:
```sql
drop table if exists member CASCADE;
create table member
(
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);
```
### 방법 3: 직접 SQL 실행
H2 콘솔에서 직접 SQL을 실행합니다:
1. 브라우저에서 `http://localhost:8080/h2-console` 접속
2. JDBC URL: `jdbc:h2:tcp://localhost/~/test`
3. User Name: `sa`
4. Connect 클릭
5. 다음 SQL 실행:
```sql
drop table if exists member CASCADE;
create table member
(
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);
```
### 방법 4: 애플리케이션 시작 시 자동 실행 (DataSourceInitializer 사용)
Java 코드에서 직접 실행하는 방법:
```java
@Configuration
public class DataSourceConfig {
    @Bean
    public DataSourceInitializer dataSourceInitializer(DataSource dataSource) {
        DataSourceInitializer initializer = new DataSourceInitializer();
        initializer.setDataSource(dataSource);
        
        ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
        populator.addScript(new ClassPathResource("schema.sql"));
        initializer.setDatabasePopulator(populator);
        
        return initializer;
    }
}
```
## 권장 해결 방법
가장 간단하고 권장되는 방법은 방법 2입니다:
1. `sql/ddl.sql` 파일의 내용을 복사
2. `src/main/resources/schema.sql` 파일 생성
3. `application.properties`에 다음 추가:
```properties
spring.sql.init.mode=always
spring.sql.init.schema-locations=classpath:schema.sql
```
이렇게 하면 애플리케이션 시작 시 자동으로 테이블이 생성됩니다.
## 참고사항
### Spring Boot SQL 초기화 동작
- `spring.sql.init.mode=always`: 항상 스크립트 실행
- `spring.sql.init.mode=embedded`: 내장 DB(H2 등)에서만 실행
- `spring.sql.init.mode=never`: 실행 안 함
### 파일 위치
- `schema.sql`: DDL (테이블 생성) 스크립트
- `data.sql`: DML (초기 데이터) 스크립트
- 모두 `src/main/resources/` 경로에 위치해야 함
### H2 데이터베이스 특징
- 인메모리 데이터베이스 또는 파일 기반 데이터베이스
- 개발/테스트 환경에서 주로 사용
- 애플리케이션 재시작 시 데이터가 사라질 수 있음 (설정에 따라)
## 정리
에러 원인: H2 데이터베이스에 `MEMBER` 테이블이 없음
해결 방법:
1. `src/main/resources/schema.sql` 파일 생성
2. DDL 스크립트 작성
3. `application.properties`에 자동 실행 설정 추가
   결과: 애플리케이션 시작 시 자동으로 테이블이 생성되어 에러가 해결됩니다.
# 애플리케이션 재시작 시 테이블 생성 동작
## 질문: 애플리케이션을 여러 번 시작하면 테이블이 매번 새로 생성되나요?
답변: `spring.sql.init.mode` 설정과 `schema.sql`의 내용에 따라 달라집니다.
## 시나리오 분석
### 시나리오 1: `spring.sql.init.mode=always` + `drop table if exists` 포함
```properties
spring.sql.init.mode=always
spring.sql.init.schema-locations=classpath:schema.sql
```
```sql
-- schema.sql
drop table if exists member CASCADE;
create table member
(
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);
```
동작:
- 매번 테이블이 새로 생성됩니다
- 애플리케이션 시작 시마다:
    1. `drop table if exists member` 실행 → 기존 테이블 삭제
    2. `create table member` 실행 → 새 테이블 생성
- 기존 데이터가 모두 삭제됩니다
### 시나리오 2: `spring.sql.init.mode=always` + `drop table` 없음
```sql
-- schema.sql (drop 문 없음)
create table member
(
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);
```
동작:
- 첫 번째 시작: 테이블 생성
- 두 번째 시작: 에러 발생
    - `Table "MEMBER" already exists` 에러 발생
- 테이블이 이미 존재하면 생성하지 않음
### 시나리오 3: `spring.sql.init.mode=embedded` (기본값)
```properties
spring.sql.init.mode=embedded
spring.sql.init.schema-locations=classpath:schema.sql
```
동작:
- 내장 데이터베이스(H2, HSQLDB, Derby)에서만 실행
- 첫 번째 시작: 테이블 생성
- 두 번째 시작:
    - 테이블이 이미 존재하면 실행 안 함 (에러 없음)
    - 데이터는 유지됨
## 실제 동작 확인
### 현재 설정 기준 (`spring.sql.init.mode=always`)
```properties
spring.sql.init.mode=always
spring.sql.init.schema-locations=classpath:schema.sql
```
schema.sql에 `drop table if exists`가 있는 경우:
```
[애플리케이션 시작 #1]
  → drop table if exists member (테이블 없음, 무시)
  → create table member (테이블 생성)
  → 데이터 저장: 회원 A, 회원 B
[애플리케이션 종료]
[애플리케이션 시작 #2]
  → drop table if exists member (기존 테이블 삭제! 데이터 손실!)
  → create table member (새 테이블 생성)
  → 데이터: 비어있음
[애플리케이션 시작 #3]
  → drop table if exists member (테이블 삭제)
  → create table member (새 테이블 생성)
  → 데이터: 비어있음
```
결론: 매번 테이블이 새로 생성되고, 기존 데이터가 모두 삭제됩니다.
## 데이터 보존을 원하는 경우
### 방법 1: `drop table` 제거
```sql
-- schema.sql
-- drop table if exists member CASCADE;  ← 주석 처리
create table member
(
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);
```
문제: 두 번째 시작부터 `Table already exists` 에러 발생
### 방법 2: `CREATE TABLE IF NOT EXISTS` 사용
```sql
-- schema.sql
-- drop table if exists member CASCADE;  ← 제거
create table if not exists member
(
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);
```
동작:
- 테이블이 없으면 생성
- 테이블이 있으면 생성 안 함 (에러 없음)
- 데이터 유지됨
### 방법 3: `spring.sql.init.mode=embedded` 사용
```properties
spring.sql.init.mode=embedded
spring.sql.init.schema-locations=classpath:schema.sql
```
동작:
- 내장 DB에서만 실행 (H2 등)
- 테이블이 이미 존재하면 실행 안 함
- 데이터 유지됨
## 개발 환경 vs 운영 환경
### 개발 환경 (권장 설정)
```properties
# 개발 중에는 데이터가 초기화되어도 괜찮은 경우
spring.sql.init.mode=always
```
```sql
-- schema.sql
drop table if exists member CASCADE;  -- 매번 초기화
create table member (...);
```
장점: 항상 깨끗한 상태로 시작
### 운영 환경 (권장 설정)
```properties
# 운영에서는 데이터 보존이 중요
spring.sql.init.mode=never  -- 또는 embedded
```
또는
```sql
-- schema.sql
create table if not exists member (...);  -- 안전한 생성
```
장점: 데이터 손실 방지
## 정리

| 설정 | `drop table` 포함 | 재시작 시 동작 | 데이터 보존 |
|------|--------------|--------------|------|
| `always` | 있음 | 매번 새로 생성 | 데이터 삭제 |
| `always` | 없음 | 첫 번째만 생성, 이후 에러 | 보존 (하지만 에러) |
| `always` | `IF NOT EXISTS` | 테이블 없을 때만 생성 | 보존 |
| `embedded` | - | 테이블 있으면 실행 안 함 | 보존 |

권장 설정:
- 개발 환경: `spring.sql.init.mode=always` + `drop table if exists` → 매번 초기화
- 운영 환경: `spring.sql.init.mode=never` 또는 `create table if not exists` → 데이터 보존
  에러가 계속 발생하는 것으로 보아 테이블이 아직 생성되지 않았습니다. 관련 설정과 파일을 확인 중입니다.
  [3 tools called]
  설정과 파일은 있지만 동작하지 않습니다. `schema.sql` 내용을 확인 중입니다.
  [2 tools called]
  `spring.sql.init.mode=embedded`인데, JDBC URL이 `jdbc:h2:tcp://localhost/~/test`(TCP 서버 모드)라서 SQL 초기화가 실행되지 않습니다. `embedded`는 내장 DB에서만 동작합니다. `spring.sql.init.mode=always`로 변경합니다.
  [1 tool called]
  설정을 수정했습니다. 문제 원인과 해결 방법을 설명합니다.
## 문제 원인
`spring.sql.init.mode=embedded`와 TCP 서버 모드의 불일치
- 현재 설정: `jdbc:h2:tcp://localhost/~/test` (TCP 서버 모드)
- `embedded` 모드는 내장 DB(인메모리 또는 임베디드 파일)에서만 동작
- TCP 서버 모드는 `embedded`로 인식되지 않아 SQL 초기화가 실행되지 않음
## 해결 방법
`spring.sql.init.mode=always`로 변경했습니다.
변경 내용:
```properties
# 변경 전
spring.sql.init.mode=embedded  # TCP 서버 모드에서는 동작 안 함
# 변경 후
spring.sql.init.mode=always  # 항상 실행
```
이제 애플리케이션을 재시작하면:
1. `schema.sql`이 자동 실행됩니다
2. `create table if not exists member`가 실행되어 테이블이 생성됩니다
3. 에러가 해결됩니다
## 참고
- `spring.sql.init.mode=always`: 항상 SQL 스크립트 실행 (TCP 서버 모드에서도 동작)
- `spring.sql.init.mode=embedded`: 내장 DB에서만 실행 (`jdbc:h2:mem:testdb` 또는 `jdbc:h2:~/test` 같은 URL에서만 동작)
  애플리케이션을 재시작하면 정상 동작해야 합니다.
# MemberServiceIntegrationTest와 데이터베이스 영향 분석
## 테스트 코드 분석
```java
@SpringBootTest
@Transactional
public class MemberServiceIntegrationTest {
    @Autowired MemberService memberService;
    @Autowired MemberRepository memberRepository;
    
    @Test
    public void 회원가입() throws Exception { ... }
    
    @Test
    public void 중복회원_예외() throws Exception { ... }
}
```
## 핵심 질문: 데이터베이스에 영향을 주나요?
### 답변: 영향을 주지 않습니다
이유: `@Transactional` 어노테이션 때문입니다.
## 테스트 실행 과정
### 1. 테스트 시작 전
```
[테스트 시작]
    ↓
[@SpringBootTest]
    ↓
[전체 Spring 컨텍스트 로드]
    ↓
- SpringConfig에서 JdbcMemberRepository 주입
- 실제 H2 데이터베이스 연결
- 테이블이 없으면 schema.sql 실행하여 생성
```
### 2. 각 테스트 메서드 실행
```
[@Test 메서드 시작]
    ↓
[@Transactional 시작]
    ↓
[트랜잭션 시작]
    ↓
[데이터베이스 작업 수행]
    - INSERT, SELECT 등 실제 DB 작업
    ↓
[테스트 완료]
    ↓
[@Transactional 종료]
    ↓
[롤백(Rollback) 실행] ← 핵심!
    ↓
[데이터베이스 변경사항 모두 취소]
```
### 3. 테스트 완료 후
```
[롤백 완료]
    ↓
[트랜잭션 종료]
    ↓
[데이터베이스는 원래 상태 유지]
    ↓
[다음 테스트 준비 완료]
```
## @Transactional의 역할
### 동작 원리
1. 트랜잭션 시작: 각 테스트 메서드 실행 전에 트랜잭션 시작
2. 데이터베이스 작업: 테스트 중 INSERT, UPDATE 등 모든 작업 수행
3. 트랜잭션 롤백: 테스트 메서드 종료 시 자동으로 롤백
### 예시: 회원가입 테스트
```
[테스트 시작]
  → 트랜잭션 시작
  → INSERT INTO member (name) VALUES ('hello')  // 실제 DB에 저장
  → SELECT * FROM member WHERE id = 1  // 데이터 조회
  → 검증: assertEquals(...)
  → 테스트 완료
  → 롤백 실행! ← INSERT가 취소됨
  → 데이터베이스: 비어있음 (원래 상태)
```
결과: 테스트가 실행되었지만, 데이터베이스에는 아무것도 남지 않습니다.
## 테스트 실행 흐름 상세
### 전체 프로세스
```
1. [Spring Boot 테스트 시작]
   └─ @SpringBootTest
      └─ 전체 애플리케이션 컨텍스트 로드
         └─ SpringConfig의 Bean 등록
            └─ JdbcMemberRepository 주입
               └─ 실제 H2 데이터베이스 연결
2. [첫 번째 테스트: 회원가입()]
   └─ @Transactional 시작
      └─ 트랜잭션 시작 (BEGIN)
         └─ memberService.join(member) 실행
            └─ INSERT INTO member (name) VALUES ('hello')
               └─ 데이터베이스에 실제로 저장됨
         └─ memberRepository.findById(saveId) 실행
            └─ SELECT * FROM member WHERE id = 1
               └─ 데이터 조회 성공
         └─ 검증: assertEquals(...)
            └─ 테스트 통과
      └─ @Transactional 종료
         └─ 롤백 실행 (ROLLBACK) ← 핵심!
            └─ INSERT가 취소됨
            └─ 데이터베이스: 비어있음
3. [두 번째 테스트: 중복회원_예외()]
   └─ @Transactional 시작
      └─ 트랜잭션 시작 (BEGIN)
         └─ memberService.join(member1) 실행
            └─ INSERT INTO member (name) VALUES ('spring')
         └─ memberService.join(member2) 실행
            └─ 중복 검증 실패
            └─ 예외 발생: IllegalStateException
         └─ 검증: assertThrows(...)
            └─ 테스트 통과
      └─ @Transactional 종료
         └─ 롤백 실행 (ROLLBACK)
            └─ 모든 변경사항 취소
4. [테스트 완료]
   └─ 데이터베이스 상태: 원래 상태 유지
   └─ 실제 운영 데이터에 영향 없음
```
## 왜 안전한가?
### 1. 트랜잭션 격리
- 각 테스트는 독립적인 트랜잭션에서 실행됩니다
- 다른 트랜잭션과 격리되어 서로 영향을 주지 않습니다
### 2. 자동 롤백
- `@Transactional`이 테스트 메서드 종료 시 자동으로 롤백합니다
- 데이터베이스 변경사항이 영구적으로 저장되지 않습니다
### 3. 테스트 전용 설정 가능
- `src/test/resources/application.properties`에 테스트 전용 설정 가능
- 운영 DB와 분리된 테스트 DB 사용 가능
## 실제 데이터베이스 영향 확인
### 시나리오: 테스트 실행 전후 비교
```
[테스트 실행 전]
  데이터베이스 상태:
  - member 테이블: 존재
  - 데이터: 비어있음 또는 기존 데이터
[테스트 실행 중]
  테스트 1: 회원가입()
    → INSERT INTO member (name) VALUES ('hello')
    → 데이터베이스: 회원 'hello' 존재
  테스트 2: 중복회원_예외()
    → INSERT INTO member (name) VALUES ('spring')
    → 데이터베이스: 회원 'spring' 존재
    → 두 번째 INSERT 시도 → 예외 발생
[테스트 완료 후 - 롤백 완료]
  데이터베이스 상태:
  - member 테이블: 존재
  - 데이터: 테스트 실행 전과 동일
  - 테스트로 인한 변경사항 없음
```
## MemberServiceTest vs MemberServiceIntegrationTest 비교
### MemberServiceTest (단위 테스트)
```java
class MemberServiceTest {
    @BeforeEach
    public void beforeEach() {
        memberRepository = new MemoryMemberRepository();  // 메모리 사용
        memberService = new MemberService(memberRepository);
    }
    
    @AfterEach
    public void afterEach() {
        memberRepository.clearStore();  // 수동 초기화
    }
}
```
특징:
- 메모리 기반 (HashMap)
- 실제 데이터베이스 사용 안 함
- 빠른 실행 속도
- 의존성 격리
### MemberServiceIntegrationTest (통합 테스트)
```java
@SpringBootTest
@Transactional
public class MemberServiceIntegrationTest {
    @Autowired MemberService memberService;  // 실제 빈 주입
    @Autowired MemberRepository memberRepository;  // 실제 DB 연결
}
```
특징:
- 실제 데이터베이스 사용 (H2)
- 전체 Spring 컨텍스트 로드
- 느린 실행 속도
- 실제 환경과 유사한 테스트
- @Transactional로 자동 롤백
## 테스트 실행 방법
### IntelliJ IDEA에서 실행
1. 개별 테스트 실행:
    - 테스트 메서드 옆의 실행 버튼 클릭
    - 또는 `Ctrl+Shift+F10` (Windows) / `Cmd+Shift+R` (Mac)
2. 전체 테스트 실행:
    - `src/test/java` 폴더 우클릭 → "Run 'All Tests'"
    - 또는 `./gradlew test` 명령어 실행
### 실행 시 주의
1. 애플리케이션이 실행 중이어도 문제 없음:
    - 테스트는 별도의 트랜잭션에서 실행됩니다
    - 롤백으로 인해 실제 데이터에 영향 없습니다
2. 테스트 전용 데이터베이스 권장:
    - `src/test/resources/application.properties` 생성
    - 테스트 전용 DB URL 설정 (예: `jdbc:h2:mem:testdb`)
## 정리

| 항목 | 영향 여부 | 이유 |
|------|-------|------|
| 테스트 실행 중 | 임시로 영향 | 실제 INSERT/UPDATE 수행 |
| 테스트 완료 후 | 영향 없음 | @Transactional 롤백으로 취소 |
| 운영 데이터 | 영향 없음 | 독립적인 트랜잭션에서 실행 |
| 다른 테스트 | 영향 없음 | 각 테스트는 독립적인 트랜잭션 |

1. @Transactional이 자동 롤백: 테스트 후 모든 변경사항이 취소됩니다
2. 트랜잭션 격리: 각 테스트는 독립적으로 실행됩니다
3. 실제 DB 사용: 통합 테스트이지만 안전하게 실행됩니다
4. 운영 데이터 보호: 롤백으로 인해 실제 데이터에 영향 없습니다
