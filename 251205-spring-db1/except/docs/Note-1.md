1. 자바 예외 계층 구조에서 애플리케이션 로직이 일반적으로 처리하지 않아야 하는 가장 심각한 오류 유형은 무엇일까요?

A
RuntimeException

B
Checked Exception

Error

D
Exception



해설
Error는 복구 불가능한 심각한 시스템 문제예요. 애플리케이션 로직에서 잡는 것은 일반적으로 권장되지 않아요. Exception 하위의 예외들을 주로 다룹니다.
2. 자바의 체크 예외(Checked Exception)와 언체크 예외(Unchecked Exception)의 가장 근본적인 차이점은 무엇일까요?

A
실행 시점에 발생하는지 여부

B
개발자가 예측 가능한지 여부

컴파일러가 처리/선언 의무를 검사하는지 여부

D
예외 발생 시 복구 가능성 여부



해설
컴파일러가 예외 처리 의무(try-catch 또는 throws 선언)를 검사하는지가 체크 예외와 언체크 예외를 구분하는 핵심 기준이에요.
3. 메서드에서 체크 예외를 발생시킬 수 있는 경우, 해당 메서드를 호출하는 쪽에서 컴파일 오류 없이 진행하기 위한 필수적인 처리 방법은 무엇일까요?

A
언체크 예외로 변환하여 다시 던진다.

try-catch 블록으로 예외를 잡거나 throws 키워드로 선언하여 던진다.

C
예외 처리를 생략하고 RuntimeException을 상속받는다.

D
로깅 프레임워크를 사용하여 예외를 기록한다.



해설
체크 예외는 컴파일러가 처리를 강제하므로, 호출하는 곳에서는 반드시 예외를 직접 잡거나(try-catch) 호출자에게 던진다고 선언(throws)해야 해요.
4. 일반적인 애플리케이션 개발에서 데이터베이스 접근 오류(SQLException)나 네트워크 연결 오류(ConnectException)와 같이 시스템 레벨의, 대부분 복구 불가능한 예외를 처리할 때 더 선호되는 예외 유형과 그 이유는 무엇일까요?

A
체크 예외 - 컴파일러가 체크해 주기 때문

B
체크 예외 - 비즈니스 로직 관련 문제이기 때문

언체크 예외 - 호출 체인에 불필요한 의존성을 만들지 않기 때문

D
언체크 예외 - 예외 처리가 완전히 필요 없기 때문



해설
시스템 레벨의 복구 불가능한 오류는 언체크 예외로 전환하여 호출 체인에 기술 의존성을 만들지 않고 공통으로 처리하는 것이 유연해요.
5. 한 예외를 잡아서 새로운 예외로 변환하여 다시 던질 때, 디버깅 시 원인(Root Cause)을 쉽게 파악하기 위해 가장 중요한 실천 방법은 무엇일까요?

A
새로운 예외 객체에 상세 메시지만 포함시킨다.

B
try-catch 블록 대신 throws를 사용하여 예외를 전파한다.

새로운 예외 생성 시 이전 예외를 'cause' 인자로 전달한다.

D
모든 예외를 최상위 Exception 타입으로 통일하여 처리한다.



해설
새로운 예외를 만들 때 이전 예외를 'cause'로 전달하면 스택 트레이스에서 'Caused by'를 통해 원인 예외를 확인하고 근본 원인을 추적할 수 있어요.